BCL — Manual de Referencia Específico: ARRAYS ASOCIATIVOS (v1.0)
----------------------------------------------------
Autor: Rafa
Fecha: Octubre 2025

Basado en BCL v1.5.1 (Edición PC). Inspirado en Tcl 8.x con sintaxis simplificada tipo BASIC.
BCL es case-insensitive y todo valor es STRING.

----------------------------------------------------
0) VISIÓN GENERAL
----------------------------------------------------
Los arrays en BCL son arrays asociativos (también llamados diccionarios o hashes en
otros lenguajes). Permiten almacenar valores indexados por claves, que pueden ser
tanto números como cadenas de texto.

La sintaxis es idéntica a Tcl:
  nombre(índice)

Características:
- Los índices pueden ser números o texto
- Los índices pueden ser variables: $nombre($variable)
- Los índices pueden ser expresiones: $array([EXPR $i + 1])
- Se pueden simular arrays multidimensionales: matriz(fila,col)
- No hay límite predefinido en el número de elementos
- Los elementos se crean dinámicamente al asignarles un valor

----------------------------------------------------
1) SINTAXIS BÁSICA
----------------------------------------------------

Asignación:
  SET nombreArray(índice) valor

Lectura:
  $nombreArray(índice)

Ejemplos:
  SET frutas(1) "manzana"
  SET frutas(2) "naranja"
  PUTS $frutas(1)    ;# manzana

  SET persona(nombre) "Juan"
  SET persona(edad) "30"
  PUTS "$persona(nombre) tiene $persona(edad) años"

----------------------------------------------------
2) ÍNDICES NUMÉRICOS
----------------------------------------------------

Los arrays pueden usar números como índices:

Ejemplo:
SET numeros(1) "uno"
SET numeros(2) "dos"
SET numeros(3) "tres"

PUTS $numeros(1)    ;# uno
PUTS $numeros(2)    ;# dos
PUTS $numeros(3)    ;# tres

Iterar con bucle:
SET i 1
WHILE $i <= 3 DO
  PUTS "numeros($i) = $numeros($i)"
  INCR i
END

----------------------------------------------------
3) ÍNDICES DE TEXTO (ASOCIATIVOS)
----------------------------------------------------

Los arrays pueden usar cadenas de texto como índices:

Ejemplo:
SET telefono(Juan) "555-1234"
SET telefono(María) "555-5678"
SET telefono(Pedro) "555-9012"

SET contacto "María"
PUTS "Teléfono de $contacto: $telefono($contacto)"
;# Teléfono de María: 555-5678

----------------------------------------------------
4) ÍNDICES VARIABLES
----------------------------------------------------

Se puede usar una variable como índice:

Ejemplo:
SET datos(lunes) "10"
SET datos(martes) "15"
SET datos(miércoles) "12"

SET dia "martes"
PUTS "Datos del $dia: $datos($dia)"
;# Datos del martes: 15

----------------------------------------------------
5) ÍNDICES CON EXPRESIONES
----------------------------------------------------

Se pueden usar expresiones como índices:

Ejemplo:
SET tabla(1) "A"
SET tabla(2) "B"
SET tabla(3) "C"

SET i 1
SET j [EXPR $i + 1]
PUTS $tabla($j)    ;# B

SET k [EXPR $i * 2]
PUTS $tabla($k)    ;# B

----------------------------------------------------
6) ARRAYS MULTIDIMENSIONALES (SIMULADOS)
----------------------------------------------------

BCL simula arrays multidimensionales usando índices compuestos:

Ejemplo - Matriz 2x2:
SET matriz(1,1) "A"
SET matriz(1,2) "B"
SET matriz(2,1) "C"
SET matriz(2,2) "D"

PUTS "$matriz(1,1) $matriz(1,2)"    ;# A B
PUTS "$matriz(2,1) $matriz(2,2)"    ;# C D

Iterar sobre matriz:
SET fila 1
WHILE $fila <= 2 DO
  SET col 1
  WHILE $col <= 2 DO
    PUTS "matriz($fila,$col) = $matriz($fila,$col)"
    INCR col
  END
  INCR fila
END

----------------------------------------------------
7) VERIFICAR EXISTENCIA DE ELEMENTOS
----------------------------------------------------

Usar INFO EXISTS para verificar si un elemento existe:

Ejemplo:
SET datos(campo1) "valor1"

IF [INFO EXISTS datos(campo1)] THEN
  PUTS "El campo1 existe: $datos(campo1)"
END

IF [INFO EXISTS datos(campo2)] THEN
  PUTS "El campo2 existe"
ELSE
  PUTS "El campo2 no existe"
END

----------------------------------------------------
8) MODIFICAR VALORES
----------------------------------------------------

Los valores de array se modifican igual que las variables normales:

Ejemplo:
SET config(debug) "false"
PUTS "Debug: $config(debug)"    ;# Debug: false

SET config(debug) "true"
PUTS "Debug: $config(debug)"    ;# Debug: true

----------------------------------------------------
9) ARRAYS EN PROCEDIMIENTOS
----------------------------------------------------

Los arrays se pasan y usan igual que las variables normales:

Ejemplo:
PROC mostrar_persona WITH DO
  GLOBAL persona
  PUTS "Nombre: $persona(nombre)"
  PUTS "Edad: $persona(edad)"
END

SET persona(nombre) "Ana"
SET persona(edad) "25"
mostrar_persona

----------------------------------------------------
10) CASOS DE USO PRÁCTICOS
----------------------------------------------------

10.1) Directorio Telefónico
SET telefono(Juan) "555-1234"
SET telefono(María) "555-5678"
SET telefono(Pedro) "555-9012"

PROC buscar_telefono WITH nombre DO
  GLOBAL telefono
  IF [INFO EXISTS telefono($nombre)] THEN
    RETURN $telefono($nombre)
  ELSE
    RETURN "No encontrado"
  END
END

PUTS [buscar_telefono "María"]    ;# 555-5678

10.2) Configuración de Aplicación
SET config(host) "localhost"
SET config(port) "8080"
SET config(timeout) "30"
SET config(debug) "true"

PUTS "Servidor: $config(host):$config(port)"
PUTS "Timeout: $config(timeout)s"

10.3) Contador de Eventos
SET contador(login) "0"
SET contador(logout) "0"
SET contador(error) "0"

PROC registrar_evento WITH tipo DO
  GLOBAL contador
  SET contador($tipo) [EXPR $contador($tipo) + 1]
END

registrar_evento "login"
registrar_evento "login"
registrar_evento "logout"

PUTS "Logins: $contador(login)"    ;# Logins: 2

10.4) Tabla de Multiplicar
SET num 7
SET i 1
WHILE $i <= 10 DO
  SET tabla($num,$i) [EXPR $num * $i]
  PUTS "$num x $i = $tabla($num,$i)"
  INCR i
END

10.5) Base de Datos Simple
SET emp001(nombre) "Carlos López"
SET emp001(puesto) "Gerente"
SET emp001(salario) "5000"

SET emp002(nombre) "Ana Martínez"
SET emp002(puesto) "Desarrolladora"
SET emp002(salario) "4000"

PROC mostrar_empleado WITH id DO
  GLOBAL emp001 emp002
  SET nombre "$id(nombre)"
  PUTS "ID: $id"
  PUTS "Nombre: $$nombre"
  PUTS "Puesto: $$id(puesto)"
  PUTS "Salario: $$id(salario)"
END

----------------------------------------------------
11) DIFERENCIAS CON LISTAS
----------------------------------------------------

Arrays vs Listas:

ARRAYS:
- Acceso por índice: $array(índice)
- Índices arbitrarios (números o texto)
- No tienen orden garantizado
- Creación dinámica de elementos
- Ideal para mapeos clave-valor

LISTAS:
- Acceso secuencial: [LINDEX $lista índice]
- Índices numéricos consecutivos (0, 1, 2...)
- Mantienen orden de inserción
- Se crean con LIST
- Ideal para colecciones ordenadas

----------------------------------------------------
12) LIMITACIONES Y NOTAS
----------------------------------------------------

- Los arrays en BCL son siempre asociativos (hash tables internamente)
- No hay sintaxis especial para eliminar elementos individuales
- Para "borrar" un elemento, usar UNSET nombre(índice)
- Los índices se tratan siempre como strings internamente
- Los índices numéricos son strings: "1", "2", "3", etc.
- No hay funciones específicas para iterar arrays (usar bucles manuales)

----------------------------------------------------
13) EJEMPLOS AVANZADOS
----------------------------------------------------

13.1) Cache de Resultados
PROC fibonacci WITH n DO
  GLOBAL fib_cache
  IF [INFO EXISTS fib_cache($n)] THEN
    RETURN $fib_cache($n)
  END

  IF $n <= 1 THEN
    SET fib_cache($n) $n
    RETURN $n
  END

  SET f1 [fibonacci [EXPR $n - 1]]
  SET f2 [fibonacci [EXPR $n - 2]]
  SET result [EXPR $f1 + $f2]
  SET fib_cache($n) $result
  RETURN $result
END

PUTS [fibonacci 10]    ;# 55

13.2) Histograma de Frecuencias
SET texto "hola mundo hola BCL mundo BCL BCL"
SET palabras [SPLIT $texto " "]

SET i 0
SET len [LLENGTH $palabras]
WHILE $i < $len DO
  SET palabra [LINDEX $palabras $i]
  IF [INFO EXISTS freq($palabra)] THEN
    SET freq($palabra) [EXPR $freq($palabra) + 1]
  ELSE
    SET freq($palabra) 1
  END
  INCR i
END

PUTS "Frecuencias:"
PUTS "  hola: $freq(hola)"
PUTS "  mundo: $freq(mundo)"
PUTS "  BCL: $freq(BCL)"

----------------------------------------------------
14) BUENAS PRÁCTICAS
----------------------------------------------------

1. Usar nombres descriptivos para arrays:
   Bueno:  SET telefono(Juan) "555-1234"
   Malo:   SET t(J) "555-1234"

2. Usar índices consistentes:
   Bueno:  SET persona(nombre), SET persona(edad)
   Malo:   SET persona(nombre), SET persona(1)

3. Verificar existencia antes de acceder:
   IF [INFO EXISTS config(debug)] THEN
     SET debug $config(debug)
   ELSE
     SET debug "false"
   END

4. Usar GLOBAL en procedimientos si se modifican arrays:
   PROC actualizar_config DO
     GLOBAL config
     SET config(version) "2.0"
   END

5. Documentar la estructura de arrays complejos:
   # empleado(nombre), empleado(puesto), empleado(salario)
   SET empleado(nombre) "Carlos"

----------------------------------------------------
15) RESUMEN RÁPIDO
----------------------------------------------------

Crear/Asignar:
  SET array(índice) valor
  SET array(clave) valor
  SET array(fila,col) valor

Leer:
  $array(índice)
  $array($variable)
  $array([EXPR $i + 1])

Verificar:
  INFO EXISTS array(índice)

Borrar:
  UNSET array(índice)

Ejemplos:
  SET frutas(1) "manzana"
  SET telefono(Juan) "555-1234"
  SET matriz(2,3) "valor"
  PUTS $frutas(1)

----------------------------------------------------
FIN DEL DOCUMENTO
----------------------------------------------------
