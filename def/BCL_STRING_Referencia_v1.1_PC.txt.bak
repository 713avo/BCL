# BCL — STRING: Referencia Completa (v1.1, alineado con Tcl 8.6.13)

**Ámbito:** Este documento redefine y amplía el comando `STRING` de BCL para alinearlo con Tcl 8.6.13, manteniendo el **estilo BCL** (sin guiones `-` en opciones; palabras clave claras; *case-insensitive*).  
**Forma general:** `SET out [STRING SUBCOMANDO ...]`  
**Índices de caracteres:** admiten **enteros**, `end`, `end-N`, `M+N`, `M-N` (como Tcl). Índice base **0**.

---

## 0) Resumen de subcomandos soportados

- **CAT**, **COMPARE**, **EQUAL**, **FIRST**, **LAST**, **INDEX**, **IS**, **LENGTH**, **MAP**, **MATCH**, **RANGE**, **REPEAT**, **REPLACE**, **REVERSE**, **TOLOWER**, **TOTITLE**, **TOUPPER**, **TRIM**, **TRIMLEFT**, **TRIMRIGHT**, **WORDSTART**, **WORDEND**.  
- (Obsoletos en Tcl y NO recomendados: **BYTELENGTH**).

---

## 1) CAT — concatenación

**Sintaxis:** `SET out [STRING CAT s1 s2 ...]`  
**Notas:** Equivalente a yuxtaponer, pero útil con comillas/macro y más eficiente que `JOIN ""`.

**Ejemplo:**
```
SET out [STRING CAT "hola" " " "mundo"]   ;# "hola mundo"
```

---

## 2) COMPARE — comparación lexicográfica

**Sintaxis:** `SET r [STRING COMPARE s1 s2 [CASE NOCASE] [LENGTH n]]`  
**Retorno:** `-1 | 0 | 1` (s1 < s2, igual, mayor).  
**Notas:** `CASE NOCASE` ignora mayúsculas; `LENGTH n` compara sólo los primeros `n` caracteres (n<0 se ignora).

**Ejemplos:**
```
SET r [STRING COMPARE "Ana" "ana"]            ;#  < 0 (ASCII, case-sensitive)
SET r [STRING COMPARE "Ana" "ana" CASE NOCASE];#  0
SET r [STRING COMPARE "abcdef" "abcXYZ" LENGTH 3] ;# 0
```

---

## 3) EQUAL — igualdad exacta

**Sintaxis:** `SET ok [STRING EQUAL s1 s2 [CASE NOCASE] [LENGTH n]]`  
**Retorno:** `1` si idénticas, `0` si no.

**Ejemplos:**
```
SET ok [STRING EQUAL "hola" "hola"]               ;# 1
SET ok [STRING EQUAL "Hola" "hola" CASE NOCASE]   ;# 1
```

---

## 4) FIRST — búsqueda de la primera aparición

**Sintaxis:** `SET idx [STRING FIRST needle haystack [START i]]`  
**Retorno:** índice (0..N-1) o `-1` si no encuentra.  
**Ejemplo:**
```
SET i [STRING FIRST "a" "012345a789abcdef" START 5]   ;# 10
```

---

## 5) LAST — búsqueda de la última aparición

**Sintaxis:** `SET idx [STRING LAST needle haystack [LAST i]]`  
**Retorno:** índice de la **última** coincidencia ≤ `i` o `-1`.  
**Ejemplo:**
```
SET i [STRING LAST "a" "0a23456789abcdef" LAST 15]    ;# 10
SET j [STRING LAST "a" "0a23456789abcdef" LAST 9]     ;# 1
```

---

## 6) INDEX — carácter en posición

**Sintaxis:** `SET ch [STRING INDEX s i]`  
**Notas:** Devuelve `""` si `i` fuera de rango. Admite `end`, `end-1`, etc.

**Ejemplo:**
```
SET ch [STRING INDEX "ABCDE" 3]   ;# "D"
SET ch [STRING INDEX "ABCDE" end] ;# "E"
```

---

## 7) IS — comprobaciones de clase

**Sintaxis:** `SET ok [STRING IS clase s [STRICT] [FAILINDEX var]]`  
**Clases (Tcl 8.6):** `ALNUM ALPHA ASCII BOOLEAN CONTROL DIGIT DOUBLE ENTIER FALSE GRAPH INTEGER LIST LOWER PRINT PUNCT SPACE TRUE UPPER WIDEINTEGER WORDCHAR XDIGIT`  
**Notas:** `STRICT` hace que `""` devuelva `0` (por defecto, `""` → `1` para muchas clases). `FAILINDEX var` guarda el índice de fallo si retorna `0` (no se define si retorna `1`).

**Ejemplos:**
```
SET ok [STRING IS INTEGER "  42  "]      ;# 1
SET ok [STRING IS DOUBLE  "12.5e-3"]     ;# 1
SET ok [STRING IS ALPHA   "abc123"]      ;# 0  (fallo en pos 3)
STRING IS ALPHA "abc123" FAILINDEX k     ;# k=3
```

---

## 8) LENGTH — longitud en caracteres

**Sintaxis:** `SET n [STRING LENGTH s]`  
**Notas:** Si el valor interno fuera binario/bytearray, devuelve bytes.

**Ejemplo:**
```
SET n [STRING LENGTH "áé"]  ;# 2
```

---

## 9) MAP — reemplazos por pares

**Sintaxis:** `SET out [STRING MAP mapping string [CASE NOCASE]]`  
**`mapping`** es una lista: `k1 v1 k2 v2 ...`.  
**Orden:** se aplica en orden de aparición de claves (como Tcl).

**Ejemplos:**
```
SET map [LIST "<" "&lt;" ">" "&gt;"]
SET esc [STRING MAP $map "a < b > c"]           ;# "a &lt; b &gt; c"
SET esc2[STRING MAP $map "A < B" CASE NOCASE]   ;# ignora mayúsculas
```

---

## 10) MATCH — patrón tipo glob

**Sintaxis:** `SET ok [STRING MATCH pattern s [CASE NOCASE]]`  
**Patrones:** `*` (cualquiera), `?` (1 char), `[chars]`, `\x` escapado.  
**Ejemplos:**
```
SET ok [STRING MATCH "*.txt" "readme.txt"]      ;# 1
SET ok [STRING MATCH "*.TXT" "readme.txt"]      ;# 0
SET ok [STRING MATCH "*.TXT" "readme.txt" CASE NOCASE] ;# 1
```

---

## 11) RANGE — subcadena

**Sintaxis:** `SET out [STRING RANGE s first last]`  
**Reglas:** si `first<0` ⇒ 0; si `last>=len` ⇒ `end`; si `first>last` ⇒ `""`.

**Ejemplos:**
```
SET r [STRING RANGE "abcdef" 1 3]   ;# "bcd"
SET r [STRING RANGE "abcdef" 2 end] ;# "cdef"
```

---

## 12) REPEAT — repetir cadena

**Sintaxis:** `SET out [STRING REPEAT s count]`  
**Ejemplo:**
```
SET bar [STRING REPEAT "-" 10]   ;# "----------"
```

---

## 13) REPLACE — reemplazar un tramo

**Sintaxis:** `SET out [STRING REPLACE s first last [new]]`  
**Comportamiento:** elimina el tramo `first..last` (incl.), e inserta `new` si se especifica.  
**Bordes:** si `first>last` o fuera de rango según reglas de Tcl, puede devolverse la original.

**Ejemplos:**
```
SET out [STRING REPLACE "abcdef" 2 3 "ZZ"] ;# "abZZef"
SET out [STRING REPLACE "abcdef" 1 1 "X"]  ;# "aXcdef"
```

---

## 14) REVERSE — invertir

**Sintaxis:** `SET out [STRING REVERSE s]`  
**Ejemplo:**
```
SET r [STRING REVERSE "abcd"]   ;# "dcba"
```

---

## 15) TOLOWER / TOTITLE / TOUPPER — cambio de caso

**Sintaxis:**
```
SET out [STRING TOLOWER s [first [last]]]
SET out [STRING TOTITLE s [first [last]]]
SET out [STRING TOUPPER s [first [last]]]
```
**Ejemplos:**
```
SET a [STRING TOLOWER "ÄBC"]        ;# "äbc"
SET b [STRING TOUPPER "abc" 1 2]    ;# "aBC"
SET c [STRING TOTITLE "hOLa"]       ;# "Hola"
```

---

## 16) TRIM / TRIMLEFT / TRIMRIGHT — recortes

**Sintaxis:**
```
SET out [STRING TRIM s [chars]]
SET out [STRING TRIMLEFT s [chars]]
SET out [STRING TRIMRIGHT s [chars]]
```
**Por defecto (`chars` omitido):** recorta **espacios Unicode** (y `\0`) como en Tcl.

**Ejemplos:**
```
SET s  "   hola  "
SET t1 [STRING TRIM $s]                 ;# "hola"
SET t2 [STRING TRIMLEFT  "--abc--" "-"] ;# "abc--"
SET t3 [STRING TRIMRIGHT "--abc--" "-"] ;# "--abc"
```

---

## 17) WORDSTART / WORDEND — límites de palabra

**Sintaxis:**
```
SET i0 [STRING WORDSTART s charIndex]
SET i1 [STRING WORDEND   s charIndex]
```
**“Palabra”** = rango contiguo de alfanumérico Unicode o `_`; otro carácter aislado cuenta como palabra de 1 char.

**Ejemplo:**
```
SET s  "hola_mundo!"
SET i0 [STRING WORDSTART $s 6]    ;# 0
SET i1 [STRING WORDEND   $s 6]    ;# 10
```

---

## 18) BYTELENGTH — (OBSOLETO)

**Sintaxis:** `SET n [STRING BYTELENGTH s]`  
**Descripción:** bytes internos en UTF-8 modificado; **no** coincide necesariamente con caracteres. Evitar salvo necesidades binario/IO.

---

## 19) Índices (detalles exactos como Tcl)

- `integer`: 0..N-1  
- `end`: último carácter  
- `end-N`: N desde el final (`end-0` = `end`)  
- `M+N`, `M-N`: aritmética de índices (p.ej., `2+3` ⇒ 5)  
**Fuera de rango:** en general se saturan (p.ej., `<0` ⇒ 0; `>len` ⇒ `end`), o devuelven `""` si aplica (como `INDEX`).

---

## 20) Consideraciones de Unicode y ‘CASE NOCASE’

- `CASE NOCASE` usa reglas Unicode (no solo ASCII).  
- `IS` emplea clases Unicode (p.ej., `DIGIT` abarca dígitos fuera de 0–9).  
- `LENGTH` cuenta **caracteres**, no bytes (salvo bytearray).

---

## 21) Ejemplos integrados

```
# Normalizar espacios y capitalizar la primera letra
SET s     "   hOlA   mundo  "
SET s1    [STRING TRIM $s]
SET first [STRING TOTITLE [STRING RANGE $s1 0 0]]
SET rest  [STRING TOLOWER [STRING RANGE $s1 1 end]]
SET out   [STRING CAT $first $rest]          ;# "Hola mundo"

# Búsqueda y reemplazo dirigido por mapa (HTML escaping)
SET html  "<h1>Título</h1>"
SET MAP   [LIST "&" "&amp;" "<" "&lt;" ">" "&gt;"]
SET safe  [STRING MAP $MAP $html]            ;# "&lt;h1&gt;Título&lt;/h1&gt;"

# Validaciones
STRING IS INTEGER "  +2147483647 " FAILINDEX k ;# 1, k no definido
STRING IS INTEGER "9999999999999999999999999" FAILINDEX k ;# 0, k=-1 (overflow)
STRING IS LIST "a {b c} d"                    ;# 1
```

---

### Diferencias vs. versiones previas de BCL
- Se añaden: **CAT, EQUAL, FIRST, LAST, IS, MAP, MATCH, REPEAT, REVERSE, WORDSTART, WORDEND**.  
- Se ajustan reglas de **RANGE, REPLACE, INDEX, TRIM*** según Tcl 8.6.  
- Se definen **CASE NOCASE**, **LENGTH n**, **START i**, **LAST i**, **STRICT/FAILINDEX** como **palabras clave** (sin `-`).  
- **BYTELENGTH** queda solo por compatibilidad/documentación.

---

Fin de la especificación `STRING` (BCL v1.1).
