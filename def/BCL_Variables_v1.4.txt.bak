BCL — Manual de Referencia Específico: VARIABLES Y ÁMBITO (v1.4)
----------------------------------------------------
Autor: Rafa
Fecha: Octubre 2025

Basado en la implementación de BCL v1.5 (Edición PC).
Inspirado en Tcl 8.6.13, con sintaxis simplificada tipo BASIC.

CAMBIOS v1.4
- Eliminadas referencias a LOCAL (las variables locales se crean con SET dentro de PROC).
- APPEND se considera comando consolidado (sin nota de "nuevo").
- La expansión de variables es SIEMPRE con $var (no se permite ${var}).
- Recordatorio: los procs se invocan por su nombre (sin CALL).

----------------------------------------------------
SECCIÓN: VARIABLES EN BCL
----------------------------------------------------

En BCL, **todas las variables son STRING**. 
No existen tipos numéricos, booleanos o estructuras complejas diferenciadas.
El lenguaje convierte automáticamente los contenidos según el contexto: aritmético, lógico o textual.

Ejemplo:
SET A 10
SET B "20"
SET C [EXPR $A + $B]
PUTS [FORMAT "Resultado: %d" $C]
;# Internamente, A, B y C son strings; EXPR interpreta numéricamente cuando procede.

----------------------------------------------------
1) SET
----------------------------------------------------
Propósito:
Asigna o muestra el valor de una variable.

Sintaxis:
  SET nombre valor
  SET nombre

Notas:
- Con dos argumentos, asigna el valor.
- Con un argumento, devuelve el valor actual.
- Las variables se crean en su primera asignación.
- Los nombres no distinguen mayúsculas/minúsculas.
- Dentro de PROC, SET **crea variables locales** automáticamente.

Ejemplo básico:
SET mensaje "Hola mundo"
SET numero 42
PUTS $mensaje
PUTS $numero

Lectura del valor actual:
SET X 3
PUTS [SET X]   ;# 3

Asignación con comando:
SET suma [EXPR 5 + 7]
PUTS [FORMAT "Suma=%d" $suma]

----------------------------------------------------
1.1) Concatenación con SET (yuxtaposición)
----------------------------------------------------
En BCL, se pueden **concatenar strings** por yuxtaposición de expansiones, sin operador:
  SET destino $B$C$D
También se pueden mezclar literales y variables:
  SET saludo "Hola, "$nombre"!"

Ejemplos:
SET B "uno"
SET C "dos"
SET D "tres"
SET A $B$C$D
PUTS $A
;# Resultado: unodostres

SET nombre "Rafa"
SET msg "Hola, "$nombre" — bienvenido"
PUTS $msg
;# Resultado: Hola, Rafa — bienvenido

Notas:
- La yuxtaposición **construye una NUEVA cadena** (no modifica en sitio).
- Para añadir separadores explícitos, inclúyelos en literales:  SET X $A","$B

----------------------------------------------------
2) UNSET
----------------------------------------------------
Propósito:
Elimina una variable del entorno actual.

Sintaxis:
  UNSET nombre

Notas:
- Tras eliminarla, deja de existir en el entorno.
- Acceder a una variable eliminada produce error.

Ejemplo:
SET TEMP "dato temporal"
PUTS $TEMP
UNSET TEMP
;# PUTS $TEMP → error

----------------------------------------------------
3) ÁMBITO: LOCALES Y GLOBALES
----------------------------------------------------
Reglas:
- Fuera de procedimientos, las variables son **globales**.
- Dentro de `PROC`, cualquier variable creada con `SET` es **local**.
- Para leer/modificar una global desde un `PROC`, usa `GLOBAL`.

Ejemplo — variable local con SET dentro de PROC:
PROC test WITH param1 DO
  SET ALFA 1        ;# ALFA es local a test
  PUTS [FORMAT "param1=%s ALFA=%s" $param1 $ALFA]
END

test 3
;# param1=3 ALFA=1

----------------------------------------------------
4) GLOBAL
----------------------------------------------------
Propósito:
Expone variables globales dentro de un procedimiento.

Sintaxis:
  GLOBAL var1 [var2 ...]

Ejemplo:
SET contador 0
PROC incrementar WITH paso DO
  GLOBAL contador
  INCR contador $paso
  RETURN $contador
END

incrementar 5
PUTS [FORMAT "Contador global = %d" $contador]

----------------------------------------------------
5) EXPANSIÓN DE VARIABLES ($var)
----------------------------------------------------
La expansión de variables en BCL se realiza **siempre** con `$var`.
No se admite `${var}`.

Ejemplo:
SET nombre "Rafa"
PUTS "Hola $nombre"

SET pref "data"
PUTS "Ruta=$pref/file.txt"

Ejemplo con EXPR:
SET X 5
SET Y 10
SET Z [EXPR ($X + $Y) * 2]
PUTS [FORMAT "Z=%d" $Z]

----------------------------------------------------
6) VARIABLES EN PROC (invocación sin CALL)
----------------------------------------------------
Los procedimientos se invocan **por su nombre**; el retorno se captura con SET [...]

Ejemplo:
SET base 100
PROC demo WITH inc DO
  GLOBAL base
  SET local_a 5           ;# local por SET
  INCR base $inc
  RETURN [FORMAT "local_a=%d base=%d" $local_a $base]
END

SET salida [demo 20]
PUTS $salida
PUTS [FORMAT "Base final=%d" $base]

----------------------------------------------------
7) APPEND
----------------------------------------------------
Propósito:
Concatena uno o más valores **al final** de una variable **modificándola en sitio**.
Si la variable no existe, se crea como cadena vacía y luego se añaden los valores.
Devuelve el **nuevo contenido** de la variable.

Sintaxis:
  APPEND var ?valor valor ...?

Reglas y notas:
- `APPEND` modifica la variable objetivo (efecto colateral) y retorna el resultado.
- Si no se proporcionan `valor`es, devuelve el valor actual (o cadena vacía si no existe).
- Es más eficiente que construir repetidamente con SET y yuxtaposición en bucles largos.
- **APPEND opera sobre strings.** Para añadir elementos a una **lista**, usar `LAPPEND`.

Ejemplos básicos:
SET s "Hola"
APPEND s ", mundo"
PUTS $s                   ;# "Hola, mundo"

; Crear si no existía:
UNSET t
APPEND t "a" "b" "c"
PUTS $t                   ;# "abc"

; Retorno del nuevo valor:
SET r [APPEND s "!!!"]
PUTS $r                   ;# "Hola, mundo!!!"

Ejemplo con variables:
SET A "uno"
SET B "dos"
SET C "tres"
SET X ""                  ;# o UNSET X
APPEND X $A "," $B "," $C
PUTS $X                   ;# "uno,dos,tres"

Comparativa con SET + yuxtaposición:
; SET crea una nueva cadena (no modifica en sitio)
SET Y $A","$B","$C
; APPEND muta en sitio (útil en acumulaciones):
SET Z ""
FOREACH e IN [LIST a b c d] DO
  APPEND Z $e
END
PUTS $Z                   ;# "abcd"

Precaución sobre listas:
SET L [LIST a b]
; APPEND L " c"        ;# concatena texto " c" al string L (no añade un elemento de lista)
; Para listas, usar LAPPEND:
SET L [LAPPEND $L c]     ;# → "a b c"

----------------------------------------------------
8) VARIABLES Y LISTAS
----------------------------------------------------
Las listas son strings; almacénalas en variables y usa comandos de lista para operarlas.

SET L [LIST uno dos tres]
FOREACH elem IN $L DO
  PUTS $elem
END

SET segundo [LINDEX $L 1]
PUTS "Elemento 2: $segundo"

----------------------------------------------------
9) VARIABLES EN EXPRESIONES
----------------------------------------------------
SET A 5
SET B 2
SET C [EXPR ($A * $B) + 10]
PUTS [FORMAT "Resultado=%d" $C]

----------------------------------------------------
10) REPL Y TEMPORALES
----------------------------------------------------
BCL> SET A 10
BCL> SET B 20
BCL> SET C [EXPR $A + $B]
BCL> PUTS "Total=$C"

----------------------------------------------------
11) BUENAS PRÁCTICAS
----------------------------------------------------
- Usa GLOBAL solo cuando sea necesario compartir estado.
- Dentro de PROC, crea locales con SET (no existe LOCAL).
- Para concatenación repetida en bucles, prefiere APPEND.
- Para listas, distingue APPEND (string) de LAPPEND (lista).
- Nombres descriptivos mejoran la legibilidad.

----------------------------------------------------
12) RESUMEN DE COMANDOS
----------------------------------------------------
SET         -> Asigna o muestra valor (crea locales en PROC)
UNSET       -> Elimina variable
GLOBAL      -> Expone variables globales dentro de PROC
APPEND      -> Concatena strings al final de una variable (in-place)
$var        -> Expansión de variables

----------------------------------------------------
FIN DEL DOCUMENTO
----------------------------------------------------
