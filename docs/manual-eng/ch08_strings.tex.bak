% ============================================================================
% CHAPTER 8: STRING MANIPULATION
% ============================================================================

\chapter{String Manipulation}
\label{ch:strings}

Strings (text) are the foundation of BCL. Since everything in BCL is a string, understanding how to manipulate text is essential. This chapter covers all the tools BCL provides for working with strings.

\section{What Are Strings?}

A string is simply a sequence of characters—letters, numbers, symbols, spaces, etc. In BCL, strings can be:

\begin{itemize}
  \item Single words: \texttt{hello}
  \item Sentences: \texttt{Hello, World!}
  \item Numbers stored as text: \texttt{42} or \texttt{3.14}
  \item Empty: \texttt{""} (a string with no characters)
\end{itemize}

\begin{examplebox}[title=Creating Strings]
\begin{lstlisting}[language=BCL]
# Simple strings
SET greeting "Hello"
SET message "Welcome to BCL programming!"

# Strings with numbers
SET year "2025"
SET price "19.99"

# Empty string
SET empty ""

# Strings with special characters
SET symbols "!@#$%^&*()"
\end{lstlisting}
\end{examplebox}

\begin{notebox}
Remember: In BCL, everything is a string. Even the number \texttt{42} is stored as the two-character string "4" and "2".
\end{notebox}

\section{The STRING Command}

The \cmd{STRING} command is your Swiss Army knife for text manipulation. It has many subcommands, each performing a specific operation.

\textbf{General Syntax:}
\begin{lstlisting}[language=BCL]
STRING subcommand arguments...
\end{lstlisting}

\subsection{STRING LENGTH - Measuring Text}

\cmd{STRING LENGTH} tells you how many characters are in a string.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING LENGTH string
\end{lstlisting}

\begin{examplebox}[title=String Length]
\begin{lstlisting}[language=BCL]
SET word "hello"
SET len [STRING LENGTH $word]
PUTS "The word '$word' has $len characters"

SET sentence "This is a test"
PUTS "Length: [STRING LENGTH $sentence]"

# Empty string has length 0
SET empty ""
PUTS "Empty string length: [STRING LENGTH $empty]"
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
The word 'hello' has 5 characters
Length: 14
Empty string length: 0
\end{verbatim}
\end{examplebox}

\begin{tipbox}
The length includes spaces and punctuation. "hi!" has length 3, not 2.
\end{tipbox}

\subsection{STRING INDEX - Getting Single Characters}

\cmd{STRING INDEX} extracts one character from a specific position.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING INDEX string position
\end{lstlisting}

\begin{notebox}
Positions start at 0! The first character is at position 0, the second at position 1, etc.
\end{notebox}

\begin{examplebox}[title=Extracting Characters]
\begin{lstlisting}[language=BCL]
SET text "HELLO"

# Get first character (position 0)
SET first [STRING INDEX $text 0]
PUTS "First: $first"  # H

# Get third character (position 2)
SET third [STRING INDEX $text 2]
PUTS "Third: $third"  # L

# Get last character
SET len [STRING LENGTH $text]
SET last_pos [EXPR $len - 1]
SET last [STRING INDEX $text $last_pos]
PUTS "Last: $last"  # O

# You can use 'end' for the last character
SET last2 [STRING INDEX $text end]
PUTS "Also last: $last2"  # O
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
First: H
Third: L
Last: O
Also last: O
\end{verbatim}
\end{examplebox}

\subsection{STRING RANGE - Extracting Substrings}

\cmd{STRING RANGE} extracts a portion of a string from one position to another.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING RANGE string start end
\end{lstlisting}

\begin{examplebox}[title=Substring Extraction]
\begin{lstlisting}[language=BCL]
SET text "Hello, World!"

# Get first 5 characters (positions 0-4)
SET hello [STRING RANGE $text 0 4]
PUTS $hello  # Hello

# Get "World" (positions 7-11)
SET world [STRING RANGE $text 7 11]
PUTS $world  # World

# Get from position 7 to the end
SET rest [STRING RANGE $text 7 end]
PUTS $rest  # World!

# Get last 6 characters
SET last [STRING RANGE $text end-5 end]
PUTS $last  # World!
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Hello
World
World!
World!
\end{verbatim}
\end{examplebox}

\begin{tipbox}
Use \texttt{end} to refer to the last position, and \texttt{end-N} to count backwards from the end.
\end{tipbox}

\subsection{STRING TOUPPER and TOLOWER - Changing Case}

These commands convert strings to uppercase or lowercase.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING TOUPPER string
STRING TOLOWER string
\end{lstlisting}

\begin{examplebox}[title=Case Conversion]
\begin{lstlisting}[language=BCL]
SET text "Hello World"

SET upper [STRING TOUPPER $text]
PUTS $upper  # HELLO WORLD

SET lower [STRING TOLOWER $text]
PUTS $lower  # hello world

# Useful for case-insensitive comparisons
SET input "YES"
SET normalized [STRING TOLOWER $input]

IF $normalized = "yes" THEN
  PUTS "User said yes!"
END
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
HELLO WORLD
hello world
User said yes!
\end{verbatim}
\end{examplebox}

\subsection{STRING TRIM - Removing Whitespace}

\cmd{STRING TRIM} removes spaces, tabs, and newlines from the beginning and/or end of a string.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING TRIM string              # Remove from both ends
STRING TRIMLEFT string          # Remove from left only
STRING TRIMRIGHT string         # Remove from right only
STRING TRIM string characters   # Remove specific characters
\end{lstlisting}

\begin{examplebox}[title=Trimming Whitespace]
\begin{lstlisting}[language=BCL]
# User input often has extra spaces
SET input "   hello   "

SET clean [STRING TRIM $input]
PUTS "[$clean]"  # [hello]

# Trim only from left
SET left [STRING TRIMLEFT $input]
PUTS "[$left]"  # [hello   ]

# Trim only from right
SET right [STRING TRIMRIGHT $input]
PUTS "[$right]"  # [   hello]

# Trim specific characters
SET text "***Hello***"
SET trimmed [STRING TRIM $text "*"]
PUTS $trimmed  # Hello
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
[hello]
[hello   ]
[   hello]
Hello
\end{verbatim}
\end{examplebox}

\subsection{STRING COMPARE - Comparing Strings}

\cmd{STRING COMPARE} compares two strings and returns:
\begin{itemize}
  \item -1 if first string comes before second (alphabetically)
  \item 0 if strings are identical
  \item 1 if first string comes after second
\end{itemize}

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING COMPARE string1 string2
STRING COMPARE -nocase string1 string2  # Ignore case
\end{lstlisting}

\begin{examplebox}[title=String Comparison]
\begin{lstlisting}[language=BCL]
# Exact comparison
SET result [STRING COMPARE "apple" "banana"]
PUTS $result  # -1 (apple comes before banana)

SET result [STRING COMPARE "zoo" "ant"]
PUTS $result  # 1 (zoo comes after ant)

SET result [STRING COMPARE "hello" "hello"]
PUTS $result  # 0 (identical)

# Case-insensitive comparison
SET r1 [STRING COMPARE "Hello" "hello"]
PUTS "Case-sensitive: $r1"  # 1 (different)

SET r2 [STRING COMPARE -nocase "Hello" "hello"]
PUTS "Case-insensitive: $r2"  # 0 (same)
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
-1
1
0
Case-sensitive: 1
Case-insensitive: 0
\end{verbatim}
\end{examplebox}

\subsection{STRING FIRST and LAST - Finding Substrings}

These commands find the position of a substring within a string.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING FIRST substring string [startpos]
STRING LAST substring string [startpos]
\end{lstlisting}

\begin{examplebox}[title=Finding Substrings]
\begin{lstlisting}[language=BCL]
SET text "hello world, hello BCL"

# Find first occurrence of "hello"
SET pos [STRING FIRST "hello" $text]
PUTS "First 'hello' at position: $pos"  # 0

# Find last occurrence of "hello"
SET pos [STRING LAST "hello" $text]
PUTS "Last 'hello' at position: $pos"  # 13

# Search starting from position 5
SET pos [STRING FIRST "hello" $text 5]
PUTS "Next 'hello' after pos 5: $pos"  # 13

# Not found returns -1
SET pos [STRING FIRST "goodbye" $text]
IF $pos = -1 THEN
  PUTS "'goodbye' not found"
END
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
First 'hello' at position: 0
Last 'hello' at position: 13
Next 'hello' after pos 5: 13
'goodbye' not found
\end{verbatim}
\end{examplebox}

\subsection{STRING REPLACE - Replacing Text}

\cmd{STRING REPLACE} replaces part of a string with new text.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING REPLACE string start end newtext
\end{lstlisting}

\begin{examplebox}[title=Replacing Parts of Strings]
\begin{lstlisting}[language=BCL]
SET text "Hello World"

# Replace "World" (positions 6-10) with "BCL"
SET new [STRING REPLACE $text 6 10 "BCL"]
PUTS $new  # Hello BCL

# Replace first word
SET new [STRING REPLACE $text 0 4 "Goodbye"]
PUTS $new  # Goodbye World

# Delete part of string (replace with empty)
SET text "Hello, World!"
SET new [STRING REPLACE $text 5 6 ""]
PUTS $new  # Hello World!
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Hello BCL
Goodbye World
Hello World!
\end{verbatim}
\end{examplebox}

\subsection{STRING REVERSE - Reversing Text}

\cmd{STRING REVERSE} reverses the order of characters in a string.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING REVERSE string
\end{lstlisting}

\begin{examplebox}[title=Reversing Strings]
\begin{lstlisting}[language=BCL]
SET text "hello"
SET reversed [STRING REVERSE $text]
PUTS $reversed  # olleh

SET text "racecar"
SET rev [STRING REVERSE $text]
IF $text = $rev THEN
  PUTS "'$text' is a palindrome!"
END
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
olleh
'racecar' is a palindrome!
\end{verbatim}
\end{examplebox}

\subsection{STRING MATCH - Pattern Matching}

\cmd{STRING MATCH} checks if a string matches a pattern with wildcards.

\textbf{Patterns:}
\begin{itemize}
  \item \texttt{*} - matches any sequence of characters
  \item \texttt{?} - matches any single character
  \item \texttt{[abc]} - matches any character in brackets
\end{itemize}

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
STRING MATCH pattern string
STRING MATCH -nocase pattern string  # Ignore case
\end{lstlisting}

\begin{examplebox}[title=Pattern Matching]
\begin{lstlisting}[language=BCL]
# Match with wildcards
IF [STRING MATCH "*.txt" "document.txt"] THEN
  PUTS "It's a text file"
END

# Match any 3-letter word
IF [STRING MATCH "???" "cat"] THEN
  PUTS "Three letter word"
END

# Match email pattern
SET email "user@example.com"
IF [STRING MATCH "*@*.*" $email] THEN
  PUTS "Looks like an email"
END

# Character sets
IF [STRING MATCH "\[0-9\]*" "123abc"] THEN
  PUTS "Starts with a digit"
END
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
It's a text file
Three letter word
Looks like an email
Starts with a digit
\end{verbatim}
\end{examplebox}

\section{FORMAT and SCAN - Formatted Text}

\subsection{FORMAT: Creating Formatted Output}

\cmd{FORMAT} creates formatted strings, similar to printf in C.

\textbf{Common Format Specifiers:}
\begin{table}[h]
\centering
\caption{FORMAT Specifiers}
\label{tab:format_specs}
\begin{tabular}{ll}
\toprule
\textbf{Specifier} & \textbf{Description} \\
\midrule
\texttt{\%s} & String \\
\texttt{\%d} & Integer (decimal) \\
\texttt{\%f} & Floating-point number \\
\texttt{\%x} & Hexadecimal \\
\texttt{\%o} & Octal \\
\texttt{\%c} & Character (from ASCII code) \\
\texttt{\%\%} & Literal \% sign \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Width and Precision:}
\begin{itemize}
  \item \texttt{\%10s} - String with minimum width 10 (right-aligned)
  \item \texttt{\%-10s} - String with minimum width 10 (left-aligned)
  \item \texttt{\%.2f} - Floating-point with 2 decimal places
  \item \texttt{\%8.2f} - Width 8, 2 decimal places
\end{itemize}

\begin{examplebox}[title=FORMAT Examples]
\begin{lstlisting}[language=BCL]
SET name "Alice"
SET age 30
SET height 1.68
SET score 95.5

# Basic formatting
PUTS [FORMAT "Name: %s, Age: %d" $name $age]

# Floating-point precision
PUTS [FORMAT "Height: %.2f meters" $height]
PUTS [FORMAT "Score: %.1f%%" $score]

# Width and alignment
PUTS [FORMAT "%10s | %5d | %6.2f" $name $age $height]
PUTS [FORMAT "%-10s | %-5d | %-6.2f" $name $age $height]

# Creating tables
PUTS [FORMAT "%-10s %8s %8s" "Name" "Age" "Height"]
PUTS [FORMAT "%-10s %8d %8.2f" "Alice" 30 1.68]
PUTS [FORMAT "%-10s %8d %8.2f" "Bob" 25 1.75]

# Numbers in different bases
SET num 255
PUTS [FORMAT "Decimal: %d" $num]
PUTS [FORMAT "Hex: %x" $num]
PUTS [FORMAT "Octal: %o" $num]
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Name: Alice, Age: 30
Height: 1.68 meters
Score: 95.5%
     Alice |    30 |   1.68
Alice      | 30    | 1.68
Name             Age   Height
Alice             30     1.68
Bob               25     1.75
Decimal: 255
Hex: ff
Octal: 377
\end{verbatim}
\end{examplebox}

\subsection{SCAN: Parsing Formatted Input}

\cmd{SCAN} is the opposite of \cmd{FORMAT}—it extracts values from a formatted string.

\textbf{Syntax:}
\begin{lstlisting}[language=BCL]
SCAN string format var1 var2 ...
\end{lstlisting}

\begin{examplebox}[title=SCAN Examples]
\begin{lstlisting}[language=BCL]
# Parse structured data
SET data "John 25 180.5"
SCAN $data "%s %d %f" name age height

PUTS "Name: $name"
PUTS "Age: $age"
PUTS "Height: $height"

# Parse date
SET date "2025-10-22"
SCAN $date "%d-%d-%d" year month day
PUTS "Year: $year, Month: $month, Day: $day"

# Parse key=value pairs
SET config "timeout=30"
SCAN $config "%\[^=\]=%d" key value
PUTS "Key: $key, Value: $value"

# Count items parsed
SET count [SCAN "42 3.14 hello" "%d %f %s" a b c]
PUTS "Parsed $count items"
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Name: John
Age: 25
Height: 180.5
Year: 2025, Month: 10, Day: 22
Key: timeout, Value: 30
Parsed 3 items
\end{verbatim}
\end{examplebox}

\section{Practical Examples}

\subsection{Email Validator}

\begin{examplebox}[title=Simple Email Validation]
\begin{lstlisting}[language=BCL]
PROC is_valid_email WITH email DO
  # Check for @ symbol
  SET at_pos [STRING FIRST "@" $email]
  IF $at_pos = -1 THEN
    RETURN 0
  END

  # Check for dot after @
  SET dot_pos [STRING FIRST "." $email $at_pos]
  IF $dot_pos = -1 THEN
    RETURN 0
  END

  # Basic pattern match
  IF [STRING MATCH "*@*.*" $email] THEN
    RETURN 1
  END

  RETURN 0
END

# Test the validator
SET emails [LIST "user@example.com" "invalid.email" "test@domain.co.uk"]
FOREACH email IN $emails DO
  IF [is_valid_email $email] THEN
    PUTS "$email - VALID"
  ELSE
    PUTS "$email - INVALID"
  END
END
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
user@example.com - VALID
invalid.email - INVALID
test@domain.co.uk - VALID
\end{verbatim}
\end{examplebox}

\subsection{Text Formatter}

\begin{examplebox}[title=Centering Text]
\begin{lstlisting}[language=BCL]
PROC center_text WITH text width DO
  SET len [STRING LENGTH $text]

  # Text is already too long
  IF $len >= $width THEN
    RETURN $text
  END

  # Calculate padding
  SET total_pad [EXPR $width - $len]
  SET left_pad [EXPR $total_pad / 2]

  # Create padding string
  SET padding ""
  FOR 1 TO $left_pad DO
    APPEND padding " "
  END

  # Return centered text
  RETURN $padding$text
END

# Create a title
SET title "BCL Manual"
SET line [center_text $title 40]
PUTS $line

SET border [STRING REPEAT "=" 40]
PUTS $border
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
              BCL Manual
========================================
\end{verbatim}
\end{examplebox}

\subsection{Word Counter}

\begin{examplebox}[title=Counting Words]
\begin{lstlisting}[language=BCL]
PROC count_words WITH text DO
  # Trim whitespace
  SET clean [STRING TRIM $text]

  # Empty string has 0 words
  IF [STRING LENGTH $clean] = 0 THEN
    RETURN 0
  END

  # Count spaces and add 1
  SET count 1
  SET pos 0
  WHILE 1 DO
    SET pos [STRING FIRST " " $clean $pos]
    IF $pos = -1 THEN
      BREAK
    END
    INCR count
    INCR pos
  END

  RETURN $count
END

SET sentence "The quick brown fox jumps"
SET wc [count_words $sentence]
PUTS "Words: $wc"

SET text "  Multiple   spaces   between  "
PUTS "Words in '$text': [count_words $text]"
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Words: 5
Words in '  Multiple   spaces   between  ': 4
\end{verbatim}
\end{examplebox}

\subsection{Password Strength Checker}

\begin{examplebox}[title=Check Password Strength]
\begin{lstlisting}[language=BCL]
PROC check_password WITH pass DO
  SET len [STRING LENGTH $pass]

  # Too short
  IF $len < 8 THEN
    PUTS "Weak: Too short (minimum 8 characters)"
    RETURN
  END

  # Check for digits
  SET has_digit 0
  FOR 0 TO $len-1 DO
    SET char [STRING INDEX $pass $__FOR]
    IF [STRING MATCH "\[0-9\]" $char] THEN
      SET has_digit 1
      BREAK
    END
  END

  # Check for uppercase
  SET upper [STRING TOUPPER $pass]
  SET has_upper [EXPR $pass != $upper]

  # Check for lowercase
  SET lower [STRING TOLOWER $pass]
  SET has_lower [EXPR $pass != $lower]

  # Calculate strength
  SET strength 0
  IF $len >= 8 THEN
    INCR strength
  END
  IF $len >= 12 THEN
    INCR strength
  END
  IF $has_digit THEN
    INCR strength
  END
  IF $has_upper THEN
    INCR strength
  END
  IF $has_lower THEN
    INCR strength
  END

  # Report
  IF $strength <= 2 THEN
    PUTS "Weak password"
  ELSEIF $strength <= 3 THEN
    PUTS "Medium password"
  ELSE
    PUTS "Strong password"
  END
END

check_password "hello"
check_password "hello123"
check_password "Hello123"
check_password "MyP@ssw0rd2025"
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Weak: Too short (minimum 8 characters)
Medium password
Strong password
Strong password
\end{verbatim}
\end{examplebox}

\section{Common String Patterns}

\subsection{Building Strings Efficiently}

\begin{examplebox}[title=String Building Techniques]
\begin{lstlisting}[language=BCL]
# Method 1: Using APPEND (efficient for loops)
SET result ""
FOR 1 TO 5 DO
  APPEND result "Line " $__FOR "\n"
END
PUTS $result

# Method 2: Using STRING CAT
SET str1 "Hello"
SET str2 "World"
SET combined [STRING CAT $str1 " " $str2]
PUTS $combined

# Method 3: Building with FORMAT
SET name "Alice"
SET age 30
SET message [FORMAT "%s is %d years old" $name $age]
PUTS $message
\end{lstlisting}
\end{examplebox}

\subsection{String Cleaning}

\begin{examplebox}[title=Cleaning User Input]
\begin{lstlisting}[language=BCL]
PROC clean_input WITH text DO
  # Remove leading/trailing whitespace
  SET clean [STRING TRIM $text]

  # Convert to lowercase for consistency
  SET clean [STRING TOLOWER $clean]

  # Remove extra internal spaces
  WHILE [STRING FIRST "  " $clean] != -1 DO
    SET pos [STRING FIRST "  " $clean]
    SET clean [STRING REPLACE $clean $pos $pos+1 " "]
  END

  RETURN $clean
END

SET input "  HELLO    WORLD  "
SET clean [clean_input $input]
PUTS "Original: '$input'"
PUTS "Cleaned:  '$clean'"
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
Original: '  HELLO    WORLD  '
Cleaned:  'hello world'
\end{verbatim}
\end{examplebox}

\begin{tipbox}
For complex string processing, consider using regular expressions (Chapter~\ref{ch:regexp}) for more powerful pattern matching and replacement.
\end{tipbox}
