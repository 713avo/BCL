% ============================================================================
% CAPÍTULO 12: INTERACCIÓN CON EL SISTEMA
% ============================================================================

\chapter{Interacción con el Sistema}
\label{ch:system}

BCL proporciona varios comandos para interactuar con el sistema operativo, ejecutar código dinámicamente, cargar archivos externos y controlar el flujo del programa. Este capítulo cubre estas poderosas características a nivel de sistema.

\section{Ejecución Dinámica de Código}

\subsection{EVAL - Ejecutar Cadena como Código}

\cmd{EVAL} evalúa una cadena como código BCL, permitiéndote ejecutar código que se construye en tiempo de ejecución.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
EVAL string
\end{lstlisting}

\begin{examplebox}[title=Uso Básico de EVAL]
\begin{lstlisting}[language=BCL]
# Execute code from a string
SET command "PUTS 'Hello from EVAL'"
EVAL $command

# Build code dynamically
SET varname "result"
SET value 42
SET code "SET $varname $value"
EVAL $code
PUTS "result = $result"  # Prints: result = 42

# Evaluate expressions
SET expr "5 + 3 * 2"
SET answer [EVAL "EXPR $expr"]
PUTS "Answer: $answer"  # Prints: Answer: 11
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Hello from EVAL
result = 42
Answer: 11
\end{verbatim}
\end{examplebox}

\begin{warningbox}
\cmd{EVAL} ejecuta código en el alcance actual con acceso a todas las variables. Ten mucho cuidado al evaluar entrada de usuario, ya que puede ejecutar código arbitrario. ¡Nunca uses \cmd{EVAL} con datos no confiables!
\end{warningbox}

\subsection{Ejemplos Prácticos de EVAL}

\begin{examplebox}[title=Despachador de Comandos Dinámico]
\begin{lstlisting}[language=BCL]
PROC dispatch_command WITH cmd DO
  # Map user commands to BCL code
  SWITCH $cmd
    CASE "greet" DO
      EVAL "PUTS 'Hello, user!'"
    END
    CASE "time" DO
      EVAL "PUTS [CLOCK FORMAT [CLOCK SECONDS]]"
    END
    CASE "random" DO
      EVAL "PUTS [EXPR rand() * 100]"
    END
    DEFAULT DO
      PUTS "Unknown command: $cmd"
    END
  END
END

dispatch_command "greet"
dispatch_command "time"
dispatch_command "random"
\end{lstlisting}
\end{examplebox}

\begin{examplebox}[title=Calculadora Simple con EVAL]
\begin{lstlisting}[language=BCL]
PROC calculate WITH expression DO
  # Add EXPR wrapper and evaluate
  SET code "EXPR $expression"

  # Use error handling (if available)
  SET result [EVAL $code]

  RETURN $result
END

PUTS "5 + 3 = [calculate "5 + 3"]"
PUTS "10 * 2.5 = [calculate "10 * 2.5"]"
PUTS "sqrt(16) = [calculate "sqrt(16)"]"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
5 + 3 = 8
10 * 2.5 = 25.0
sqrt(16) = 4.0
\end{verbatim}
\end{examplebox}

\section{Cargar Código Externo}

\subsection{SOURCE - Cargar y Ejecutar Archivos}

\cmd{SOURCE} carga y ejecuta código BCL desde un archivo externo, permitiéndote organizar programas grandes en módulos.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
SOURCE filepath
\end{lstlisting}

\begin{examplebox}[title=Usar SOURCE]
Crea un archivo \texttt{library.bcl}:
\begin{lstlisting}[language=BCL]
# library.bcl - Math utilities
PROC square WITH x DO
  RETURN [EXPR $x * $x]
END

PROC cube WITH x DO
  RETURN [EXPR $x * $x * $x]
END

SET PI 3.14159
\end{lstlisting}

Script principal:
\begin{lstlisting}[language=BCL]
# Load the library
SOURCE "library.bcl"

# Use functions and variables from library
PUTS "5 squared = [square 5]"
PUTS "3 cubed = [cube 3]"
PUTS "PI = $PI"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
5 squared = 25
3 cubed = 27
PI = 3.14159
\end{verbatim}
\end{examplebox}

\begin{tipbox}
Usa \cmd{SOURCE} para:
\begin{itemize}
  \item Dividir programas grandes en archivos manejables
  \item Crear módulos de biblioteca reutilizables
  \item Compartir código común entre múltiples scripts
  \item Mantener configuración en archivos separados
\end{itemize}
\end{tipbox}

\subsection{Ejemplos Prácticos de SOURCE}

\begin{examplebox}[title=Archivo de Configuración]
Crea \texttt{config.bcl}:
\begin{lstlisting}[language=BCL]
# Application configuration
SET APP_NAME "MyApp"
SET APP_VERSION "1.0.0"
SET DEBUG_MODE 1
SET MAX_USERS 100
\end{lstlisting}

Aplicación principal:
\begin{lstlisting}[language=BCL]
# Load configuration
SOURCE "config.bcl"

PUTS "=== $APP_NAME v$APP_VERSION ==="
PUTS "Debug mode: $DEBUG_MODE"
PUTS "Max users: $MAX_USERS"

IF $DEBUG_MODE THEN
  PUTS "[DEBUG] Configuration loaded successfully"
END
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
=== MyApp v1.0.0 ===
Debug mode: 1
Max users: 100
[DEBUG] Configuration loaded successfully
\end{verbatim}
\end{examplebox}

\begin{examplebox}[title=Sistema de Módulos]
Crea \texttt{string\_utils.bcl}:
\begin{lstlisting}[language=BCL]
PROC reverse_string WITH str DO
  RETURN [STRING REVERSE $str]
END

PROC count_vowels WITH str DO
  SET count 0
  SET len [STRING LENGTH $str]
  FOR 0 TO $len-1 DO
    SET char [STRING INDEX $str $__FOR]
    IF [REGEXP -nocase "\[aeiou\]" $char] THEN
      INCR count
    END
  END
  RETURN $count
END
\end{lstlisting}

Script principal:
\begin{lstlisting}[language=BCL]
SOURCE "string_utils.bcl"

SET text "Hello World"
PUTS "Original: $text"
PUTS "Reversed: [reverse_string $text]"
PUTS "Vowels: [count_vowels $text]"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Original: Hello World
Reversed: dlroW olleH
Vowels: 3
\end{verbatim}
\end{examplebox}

\section{Temporización y Retrasos}

\subsection{AFTER - Pausar Ejecución}

\cmd{AFTER} suspende la ejecución por un número especificado de milisegundos.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
AFTER milliseconds
\end{lstlisting}

\begin{examplebox}[title=Usar AFTER]
\begin{lstlisting}[language=BCL]
PUTS "Starting..."
AFTER 1000        # Wait 1 second (1000 ms)
PUTS "1 second later"

AFTER 500         # Wait 0.5 seconds
PUTS "0.5 seconds later"

AFTER 2000        # Wait 2 seconds
PUTS "Done!"
\end{lstlisting}

\textbf{Salida:} (con retrasos)
\begin{verbatim}
Starting...
[pausa de 1 segundo]
1 second later
[pausa de 0.5 segundos]
0.5 seconds later
[pausa de 2 segundos]
Done!
\end{verbatim}
\end{examplebox}

\begin{examplebox}[title=Animación de Progreso]
\begin{lstlisting}[language=BCL]
PROC show_progress WITH steps DO
  PUTSN "Progress: "

  FOR 1 TO $steps DO
    PUTSN "."
    AFTER 200
  END

  PUTS " Done!"
END

PUTS "Loading"
show_progress 10
PUTS "Complete!"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Loading
Progress: .......... Done!
Complete!
\end{verbatim}
\end{examplebox}

\begin{examplebox}[title=Temporizador de Cuenta Regresiva]
\begin{lstlisting}[language=BCL]
PROC countdown WITH seconds DO
  FOR $seconds TO 1 STEP -1 DO
    PUTS "Time remaining: $__FOR seconds"
    AFTER 1000
  END
  PUTS "Time's up!"
END

countdown 5
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Time remaining: 5 seconds
Time remaining: 4 seconds
Time remaining: 3 seconds
Time remaining: 2 seconds
Time remaining: 1 seconds
Time's up!
\end{verbatim}
\end{examplebox}

\section{Ejecución de Comandos del Sistema}

\subsection{EXEC - Ejecutar Comandos del Sistema}

\cmd{EXEC} ejecuta un comando del sistema operativo y devuelve su salida.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
EXEC command [arg1 arg2 ...]
\end{lstlisting}

\begin{warningbox}
\cmd{EXEC} típicamente solo está disponible en sistemas PC/desktop, no en microcontroladores embebidos. También plantea riesgos de seguridad si se usa con entrada no confiable.
\end{warningbox}

\begin{examplebox}[title=Uso Básico de EXEC]
\begin{lstlisting}[language=BCL]
# List files (Linux/Unix)
SET files [EXEC "ls"]
PUTS "Files:\n$files"

# Get current date
SET date [EXEC "date"]
PUTS "Current date: $date"

# Echo text
SET output [EXEC "echo" "Hello from shell"]
PUTS $output

# Count files
SET count [EXEC "ls" "-1" "|" "wc" "-l"]
PUTS "File count: $count"
\end{lstlisting}
\end{examplebox}

\begin{examplebox}[title=Ejemplos Prácticos de EXEC]
\begin{lstlisting}[language=BCL]
# Check if a file exists (using shell command)
PROC file_exists_shell WITH filename DO
  # Use test command
  SET result [EXEC "test" "-f" $filename "&&" "echo" "1" "||" "echo" "0"]
  RETURN [STRING TRIM $result]
END

# Get disk usage
PROC get_disk_usage DO
  SET usage [EXEC "df" "-h" "."]
  RETURN $usage
END

# Backup a file
PROC backup_file WITH filename DO
  SET timestamp [CLOCK FORMAT [CLOCK SECONDS] FORMAT "%Y%m%d_%H%M%S"]
  SET backup_name "$filename.backup_$timestamp"
  EXEC "cp" $filename $backup_name
  PUTS "Backed up to: $backup_name"
END

backup_file "important.txt"
\end{lstlisting}
\end{examplebox}

\section{Variables de Entorno}

\subsection{ENV - Acceder a Variables de Entorno}

\cmd{ENV} lee variables de entorno del sistema operativo.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
ENV variable_name
\end{lstlisting}

\begin{examplebox}[title=Leer Variables de Entorno]
\begin{lstlisting}[language=BCL]
# Get home directory
SET home [ENV HOME]
PUTS "Home directory: $home"

# Get current user
SET user [ENV USER]
PUTS "Current user: $user"

# Get PATH
SET path [ENV PATH]
PUTS "PATH: $path"

# Check if a variable exists
SET editor [ENV EDITOR]
IF [STRING LENGTH $editor] > 0 THEN
  PUTS "Default editor: $editor"
ELSE
  PUTS "No EDITOR set, using vi"
  SET editor "vi"
END
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Home directory: /home/user
Current user: user
PATH: /usr/local/bin:/usr/bin:/bin
Default editor: vim
\end{verbatim}
\end{examplebox}

\begin{examplebox}[title=Rutas Multiplataforma]
\begin{lstlisting}[language=BCL]
PROC get_temp_dir DO
  # Try different environment variables
  SET temp [ENV TMPDIR]
  IF [STRING LENGTH $temp] = 0 THEN
    SET temp [ENV TEMP]
  END
  IF [STRING LENGTH $temp] = 0 THEN
    SET temp [ENV TMP]
  END
  IF [STRING LENGTH $temp] = 0 THEN
    SET temp "/tmp"  # Default for Unix
  END
  RETURN $temp
END

SET tempdir [get_temp_dir]
PUTS "Temp directory: $tempdir"
\end{lstlisting}
\end{examplebox}

\section{Argumentos de Línea de Comandos}

\subsection{ARGV - Obtener Argumentos del Script}

\cmd{ARGV} devuelve la lista de argumentos de línea de comandos pasados al script.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
ARGV
\end{lstlisting}

\begin{examplebox}[title=Procesar Argumentos]
Guardar como \texttt{args.bcl}:
\begin{lstlisting}[language=BCL]
# Get arguments
SET args [ARGV]
SET count [LLENGTH $args]

PUTS "Received $count argument(s):"

IF $count == 0 THEN
  PUTS "  (none)"
ELSE
  SET i 1
  FOREACH arg IN $args DO
    PUTS "  $i. $arg"
    INCR i
  END
END
\end{lstlisting}

Ejecutar como: \texttt{bcl args.bcl one two three}

\textbf{Salida:}
\begin{verbatim}
Received 3 argument(s):
  1. one
  2. two
  3. three
\end{verbatim}
\end{examplebox}

\begin{examplebox}[title=Herramienta de Línea de Comandos]
\begin{lstlisting}[language=BCL]
# greet.bcl - A simple greeting tool
SET args [ARGV]
SET argc [LLENGTH $args]

IF $argc == 0 THEN
  PUTS "Usage: bcl greet.bcl <name> [title]"
  EXIT 1
END

SET name [LINDEX $args 0]

IF $argc >= 2 THEN
  SET title [LINDEX $args 1]
  PUTS "Hello, $title $name!"
ELSE
  PUTS "Hello, $name!"
END
\end{lstlisting}

Uso:
\begin{verbatim}
$ bcl greet.bcl Alice
Hello, Alice!

$ bcl greet.bcl Bob Dr.
Hello, Dr. Bob!
\end{verbatim}
\end{examplebox}

\section{Terminación del Programa}

\subsection{EXIT - Terminar Ejecución}

\cmd{EXIT} termina el script BCL o intérprete y devuelve un código de salida al sistema operativo.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
EXIT [code]
\end{lstlisting}

El \texttt{code} es opcional:
\begin{itemize}
  \item \texttt{0} indica éxito (predeterminado)
  \item No-cero indica un error o condición específica
\end{itemize}

\begin{examplebox}[title=Usar EXIT]
\begin{lstlisting}[language=BCL]
SET args [ARGV]

IF [LLENGTH $args] == 0 THEN
  PUTS "Error: No arguments provided"
  EXIT 1    # Exit with error code
END

# Process arguments...
PUTS "Processing..."

# Success
EXIT 0
\end{lstlisting}
\end{examplebox}

\begin{examplebox}[title=Códigos de Salida para Diferentes Errores]
\begin{lstlisting}[language=BCL]
PROC validate_file WITH filename DO
  # Check if file exists
  IF [FILE EXISTS $filename] = 0 THEN
    PUTS "Error: File '$filename' not found"
    EXIT 2    # File not found
  END

  # Check if file is readable
  # (assuming FILE READABLE command exists)
  # ...

  PUTS "File validated successfully"
END

SET args [ARGV]
IF [LLENGTH $args] == 0 THEN
  PUTS "Usage: script.bcl <filename>"
  EXIT 1    # Invalid usage
END

validate_file [LINDEX $args 0]
PUTS "Done!"
EXIT 0      # Success
\end{lstlisting}
\end{examplebox}

\section{Ejemplos Prácticos de Integración del Sistema}

\subsection{Lanzador de Scripts}

\begin{examplebox}[title=Cargador Dinámico de Scripts]
\begin{lstlisting}[language=BCL]
PROC load_plugin WITH name DO
  SET plugin_file "plugins/$name.bcl"

  IF [FILE EXISTS $plugin_file] THEN
    PUTS "Loading plugin: $name"
    SOURCE $plugin_file
    RETURN 1
  ELSE
    PUTS "Plugin not found: $name"
    RETURN 0
  END
END

# Load multiple plugins
SET plugins [LIST "database" "network" "utils"]
FOREACH plugin IN $plugins DO
  load_plugin $plugin
END
\end{lstlisting}
\end{examplebox}

\subsection{Shell Interactivo}

\begin{examplebox}[title=Shell BCL Simple]
\begin{lstlisting}[language=BCL]
PUTS "=== BCL Interactive Shell ==="
PUTS "Type 'exit' or 'quit' to exit"
PUTS ""

WHILE 1 DO
  PUTSN "BCL> "
  SET input [GETS stdin]

  # Trim input
  SET input [STRING TRIM $input]

  # Check for exit
  IF $input == "exit" OR $input == "quit" THEN
    PUTS "Goodbye!"
    BREAK
  END

  # Skip empty lines
  IF [STRING LENGTH $input] == 0 THEN
    CONTINUE
  END

  # Evaluate input as BCL code
  EVAL $input
END
\end{lstlisting}
\end{examplebox}

\subsection{Script de Construcción}

\begin{examplebox}[title=Sistema de Construcción Automatizado]
\begin{lstlisting}[language=BCL]
PROC run_command WITH description command DO
  PUTS ">>> $description"
  SET result [EXEC $command]
  PUTS $result
  RETURN [STRING LENGTH $result]
END

PROC build DO
  PUTS "==================================="
  PUTS "  Starting Build Process"
  PUTS "==================================="
  PUTS ""

  # Clean
  run_command "Cleaning old files..." "make clean"
  AFTER 500

  # Build
  run_command "Compiling..." "make"
  AFTER 500

  # Test
  run_command "Running tests..." "make test"
  AFTER 500

  PUTS ""
  PUTS "==================================="
  PUTS "  Build Complete!"
  PUTS "==================================="
END

# Check arguments
SET args [ARGV]
IF [LLENGTH $args] > 0 THEN
  SET target [LINDEX $args 0]
  IF $target == "build" THEN
    build
  ELSEIF $target == "clean" THEN
    EXEC "make clean"
  ELSE
    PUTS "Unknown target: $target"
    EXIT 1
  END
ELSE
  PUTS "Usage: build.bcl <build|clean>"
  EXIT 1
END
\end{lstlisting}
\end{examplebox}

\section{Resumen de Comandos del Sistema}

\begin{longtable}{lp{9cm}}
\caption{Comandos de Interacción con el Sistema} \\
\toprule
\textbf{Comando} & \textbf{Descripción} \\
\midrule
\endfirsthead
\multicolumn{2}{c}{{\tablename\ \thetable{} -- continuación}} \\
\toprule
\textbf{Comando} & \textbf{Descripción} \\
\midrule
\endhead
\bottomrule
\endfoot

\texttt{EVAL string} & Ejecutar cadena como código BCL \\
\texttt{SOURCE file} & Cargar y ejecutar archivo BCL externo \\
\texttt{AFTER ms} & Pausar ejecución por milisegundos \\
\texttt{EXEC cmd} & Ejecutar comando del sistema, devolver salida \\
\texttt{ENV name} & Obtener variable de entorno \\
\texttt{ARGV} & Obtener lista de argumentos de línea de comandos \\
\texttt{EXIT [code]} & Terminar programa con código de salida \\
\end{longtable}

\begin{warningbox}
Consideraciones de Seguridad:
\begin{itemize}
  \item Nunca uses \cmd{EVAL} o \cmd{EXEC} con entrada de usuario no confiable
  \item Valida y sanitiza todos los datos externos antes de usarlos en comandos
  \item Ten cuidado con \cmd{SOURCE} para evitar cargar código malicioso
  \item Usa códigos de salida de manera consistente para mejor integración con scripts de shell
\end{itemize}
\end{warningbox}

\begin{tipbox}
Mejores Prácticas:
\begin{itemize}
  \item Usa \cmd{SOURCE} para organizar proyectos grandes en módulos
  \item Almacena configuración en archivos separados cargados con \cmd{SOURCE}
  \item Usa variables de entorno para configuraciones específicas del sistema
  \item Proporciona mensajes de error útiles y códigos de salida apropiados
  \item Documenta tus módulos y bibliotecas claramente
\end{itemize}
\end{tipbox}
