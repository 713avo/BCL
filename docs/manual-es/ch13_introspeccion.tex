% ============================================================================
% CAPÍTULO 13: INTROSPECCIÓN
% ============================================================================

\chapter{Introspección}
\label{ch:introspection}

La introspección es la capacidad de un programa para examinar su propia estructura y estado mientras se ejecuta. BCL proporciona el comando \cmd{INFO}, que te permite inspeccionar variables, procedimientos y el entorno BCL mismo.

\section{¿Qué es la Introspección?}

Piensa en la introspección como la capacidad de tu programa de "mirarse en el espejo" y ver lo que contiene. Puede hacer preguntas como:

\begin{itemize}
  \item "¿Existe una variable llamada 'x'?"
  \item "¿Qué procedimientos he definido?"
  \item "¿Cuáles son los parámetros de este procedimiento?"
  \item "¿Qué versión de BCL estoy ejecutando?"
\end{itemize}

Esto es increíblemente útil para:
\begin{itemize}
  \item \textbf{Depuración} - Verificar si las variables existen antes de usarlas
  \item \textbf{Código dinámico} - Tomar decisiones basadas en lo que está disponible
  \item \textbf{Manejo de errores} - Verificar precondiciones antes de operaciones
  \item \textbf{Herramientas de desarrollo} - Construir depuradores, perfiladores o IDEs
\end{itemize}

\section{El Comando INFO}

El comando \cmd{INFO} es tu puerta de entrada a la introspección. Tiene muchos subcomandos, cada uno proporcionando información diferente sobre el estado de tu programa.

\textbf{Sintaxis General:}
\begin{lstlisting}[language=BCL]
INFO subcommand [arguments...]
\end{lstlisting}

\section{Verificar Variables}

\subsection{INFO EXISTS - ¿Existe una Variable?}

\cmd{INFO EXISTS} verifica si una variable ha sido creada y asignada un valor.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
INFO EXISTS varname
\end{lstlisting}

Devuelve 1 si la variable existe, 0 si no existe.

\begin{examplebox}[title=Verificar Existencia de Variable]
\begin{lstlisting}[language=BCL]
SET username "Alice"

# Check if variable exists
IF [INFO EXISTS username] THEN
  PUTS "username exists: $username"
ELSE
  PUTS "username doesn't exist"
END

# Check non-existent variable
IF [INFO EXISTS password] THEN
  PUTS "password exists"
ELSE
  PUTS "password doesn't exist - need to set it"
  SET password "secret123"
END

# Now it exists
IF [INFO EXISTS password] THEN
  PUTS "password now exists"
END
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
username exists: Alice
password doesn't exist - need to set it
password now exists
\end{verbatim}
\end{examplebox}

\begin{tipbox}
Usa \cmd{INFO EXISTS} para evitar errores al acceder a variables opcionales o entrada de usuario que podría no haberse proporcionado.
\end{tipbox}

\subsection{INFO VARS - Listar Todas las Variables}

\cmd{INFO VARS} devuelve una lista de todas las variables en el alcance actual.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
INFO VARS              # All variables
INFO VARS pattern      # Variables matching pattern
\end{lstlisting}

\begin{examplebox}[title=Listar Variables]
\begin{lstlisting}[language=BCL]
SET name "Alice"
SET age 30
SET city "New York"
SET temp_value 123

# List all variables
SET all_vars [INFO VARS]
PUTS "All variables: $all_vars"

# List variables matching pattern
SET temp_vars [INFO VARS "temp_*"]
PUTS "Temp variables: $temp_vars"

# List variables starting with specific letter
SET a_vars [INFO VARS "a*"]
PUTS "Variables starting with 'a': $a_vars"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
All variables: name age city temp_value
Temp variables: temp_value
Variables starting with 'a': age
\end{verbatim}
\end{examplebox}

\subsection{INFO GLOBALS - Listar Variables Globales}

\cmd{INFO GLOBALS} devuelve una lista de todas las variables globales.

\begin{examplebox}[title=Variables Globales]
\begin{lstlisting}[language=BCL]
SET global_config "production"
SET global_debug 1

PROC test DO
  SET local_var "I'm local"

  # From inside proc, check globals
  SET globals [INFO GLOBALS]
  PUTS "Global variables: $globals"

  # Check locals
  SET locals [INFO LOCALS]
  PUTS "Local variables: $locals"
END

test
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Global variables: global_config global_debug
Local variables: local_var
\end{verbatim}
\end{examplebox}

\subsection{INFO LOCALS - Listar Variables Locales}

\cmd{INFO LOCALS} devuelve variables locales al procedimiento actual.

\begin{examplebox}[title=Inspección de Variables Locales]
\begin{lstlisting}[language=BCL]
PROC calculate WITH x y DO
  SET sum [EXPR $x + $y]
  SET product [EXPR $x * $y]
  SET temp "working..."

  # Show all local variables (including parameters)
  SET locals [INFO LOCALS]
  PUTS "Local variables in procedure: $locals"

  # Show just local temp variables
  SET temps [INFO LOCALS "temp*"]
  PUTS "Temp variables: $temps"
END

calculate 5 3
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Local variables in procedure: x y sum product temp
Temp variables: temp
\end{verbatim}
\end{examplebox}

\section{Inspeccionar Procedimientos}

\subsection{INFO PROCS - Listar Todos los Procedimientos}

\cmd{INFO PROCS} devuelve una lista de todos los procedimientos definidos.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
INFO PROCS              # All procedures
INFO PROCS pattern      # Procedures matching pattern
\end{lstlisting}

\begin{examplebox}[title=Listar Procedimientos]
\begin{lstlisting}[language=BCL]
PROC calculate WITH x y DO
  RETURN [EXPR $x + $y]
END

PROC format_output WITH text DO
  PUTS "=== $text ==="
END

PROC helper_function DO
  # Helper code
END

# List all procedures
SET procs [INFO PROCS]
PUTS "All procedures:"
FOREACH proc IN $procs DO
  PUTS "  - $proc"
END

# List only helper procedures
SET helpers [INFO PROCS "helper_*"]
PUTS "\nHelper procedures: $helpers"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
All procedures:
  - calculate
  - format_output
  - helper_function

Helper procedures: helper_function
\end{verbatim}
\end{examplebox}

\subsection{INFO ARGS - Obtener Parámetros del Procedimiento}

\cmd{INFO ARGS} devuelve los nombres de parámetros para un procedimiento.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
INFO ARGS procname
\end{lstlisting}

\begin{examplebox}[title=Inspeccionar Parámetros de Procedimiento]
\begin{lstlisting}[language=BCL]
PROC greet WITH name @title DO
  IF [INFO EXISTS title] THEN
    PUTS "Hello, $title $name"
  ELSE
    PUTS "Hello, $name"
  END
END

# Get parameter list
SET params [INFO ARGS greet]
PUTS "Parameters of 'greet': $params"

# Check how many parameters
SET count [LLENGTH $params]
PUTS "Number of parameters: $count"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Parameters of 'greet': name title
Number of parameters: 2
\end{verbatim}
\end{examplebox}

\subsection{INFO BODY - Obtener Cuerpo del Procedimiento}

\cmd{INFO BODY} devuelve el código actual (cuerpo) de un procedimiento.

\textbf{Sintaxis:}
\begin{lstlisting}[language=BCL]
INFO BODY procname
\end{lstlisting}

\begin{examplebox}[title=Examinar Código de Procedimiento]
\begin{lstlisting}[language=BCL]
PROC add WITH a b DO
  SET result [EXPR $a + $b]
  RETURN $result
END

# Get the procedure body
SET body [INFO BODY add]
PUTS "Procedure 'add' contains:"
PUTS $body
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Procedure 'add' contains:
  SET result [EXPR $a + $b]
  RETURN $result
\end{verbatim}
\end{examplebox}

\begin{tipbox}
\cmd{INFO BODY} es útil para depuración, crear documentación o implementar herramientas de análisis de código.
\end{tipbox}

\section{Información del Sistema}

\subsection{INFO BCLVERSION - Obtener Versión de BCL}

\cmd{INFO BCLVERSION} devuelve la versión de BCL que estás ejecutando.

\begin{examplebox}[title=Verificación de Versión]
\begin{lstlisting}[language=BCL]
SET version [INFO BCLVERSION]
PUTS "Running BCL version: $version"

# Version-specific features
IF [STRING MATCH "1.5*" $version] THEN
  PUTS "You have BCL 1.5.x - all features available"
ELSE
  PUTS "Consider upgrading to BCL 1.5 or newer"
END
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Running BCL version: 1.5.1
You have BCL 1.5.x - all features available
\end{verbatim}
\end{examplebox}

\subsection{INFO COMMANDS - Listar Todos los Comandos Disponibles}

\cmd{INFO COMMANDS} devuelve una lista de todos los comandos BCL disponibles en el intérprete actual.

\begin{examplebox}[title=Comandos Disponibles]
\begin{lstlisting}[language=BCL]
# Get all commands
SET commands [INFO COMMANDS]
PUTS "Total commands available: [LLENGTH $commands]"

# Check if a specific command exists
IF [LSEARCH $commands "REGEXP"] != -1 THEN
  PUTS "REGEXP command is available"
END

# List string-related commands
SET string_cmds [LIST]
FOREACH cmd IN $commands DO
  IF [STRING MATCH "STRING*" $cmd] THEN
    SET string_cmds [LAPPEND $string_cmds $cmd]
  END
END
PUTS "String commands: $string_cmds"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Total commands available: 87
REGEXP command is available
String commands: STRING
\end{verbatim}
\end{examplebox}

\section{Aplicaciones Prácticas}

\subsection{Acceso Seguro a Variables}

\begin{examplebox}[title=Evitar Errores con INFO EXISTS]
\begin{lstlisting}[language=BCL]
PROC safe_print WITH varname DO
  # Check if variable exists before accessing
  IF [INFO EXISTS $varname] THEN
    # Get the value using SET without argument
    SET value [SET $varname]
    PUTS "$varname == $value"
  ELSE
    PUTS "Variable '$varname' not found"
  END
END

SET username "Alice"

safe_print username
safe_print password
safe_print email
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
username = Alice
Variable 'password' not found
Variable 'email' not found
\end{verbatim}
\end{examplebox}

\subsection{Configuración Dinámica}

\begin{examplebox}[title=Variables de Configuración Opcionales]
\begin{lstlisting}[language=BCL]
PROC load_config DO
  # Set defaults
  SET config_host "localhost"
  SET config_port 8080
  SET config_debug 0

  # Check if user provided custom values
  IF [INFO EXISTS USER_HOST] THEN
    SET config_host $USER_HOST
    PUTS "Using custom host: $config_host"
  END

  IF [INFO EXISTS USER_PORT] THEN
    SET config_port $USER_PORT
    PUTS "Using custom port: $config_port"
  END

  IF [INFO EXISTS USER_DEBUG] THEN
    SET config_debug $USER_DEBUG
    PUTS "Debug mode: $config_debug"
  END

  RETURN [LIST $config_host $config_port $config_debug]
END

# Load with defaults
SET config [load_config]
PUTS "Config: $config"

# Now set custom values
SET USER_HOST "192.168.1.100"
SET USER_PORT 3000
SET config [load_config]
PUTS "Custom config: $config"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Config: localhost 8080 0
Using custom host: 192.168.1.100
Using custom port: 3000
Custom config: 192.168.1.100 3000 0
\end{verbatim}
\end{examplebox}

\subsection{Sistema de Ayuda}

\begin{examplebox}[title=Ayuda Interactiva]
\begin{lstlisting}[language=BCL]
PROC show_help WITH @command DO
  IF [INFO EXISTS command] THEN
    # Show help for specific command
    IF [LSEARCH [INFO PROCS] $command] != -1 THEN
      PUTS "Procedure: $command"
      SET params [INFO ARGS $command]
      PUTS "Parameters: $params"
      PUTS ""
      PUTS "Body:"
      PUTS [INFO BODY $command]
    ELSE
      PUTS "Command '$command' not found"
    END
  ELSE
    # Show all available procedures
    PUTS "Available procedures:"
    SET procs [INFO PROCS]
    FOREACH proc IN $procs DO
      SET params [INFO ARGS $proc]
      PUTS "  $proc ($params)"
    END
  END
END

PROC calculate_area WITH width height DO
  RETURN [EXPR $width * $height]
END

# Show all procedures
show_help

# Show help for specific procedure
PUTS ""
show_help calculate_area
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
Available procedures:
  show_help (command)
  calculate_area (width height)

Procedure: calculate_area
Parameters: width height

Body:
  RETURN [EXPR $width * $height]
\end{verbatim}
\end{examplebox}

\subsection{Herramienta de Depuración}

\begin{examplebox}[title=Volcado de Variables]
\begin{lstlisting}[language=BCL]
PROC dump_variables WITH @pattern DO
  # Default pattern: all variables
  IF [INFO EXISTS pattern] = 0 THEN
    SET pattern "*"
  END

  SET vars [INFO VARS $pattern]

  IF [LLENGTH $vars] = 0 THEN
    PUTS "No variables match pattern '$pattern'"
    RETURN
  END

  PUTS "=== Variables matching '$pattern' ==="
  FOREACH var IN $vars DO
    SET value [SET $var]
    SET type "string"

    # Try to determine type
    IF [REGEXP "^-?\[0-9\]+$" $value] THEN
      SET type "integer"
    ELSEIF [REGEXP "^-?\[0-9\]+\\.\[0-9\]+$" $value] THEN
      SET type "float"
    END

    PUTS [FORMAT "  %-15s = %-20s (%s)" $var $value $type]
  END
END

# Create some test variables
SET name "Alice"
SET age 30
SET height 1.68
SET count 42
SET debug_flag 1

# Dump all variables
dump_variables

# Dump only specific pattern
PUTS ""
dump_variables "debug_*"
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
=== Variables matching '*' ===
  name            = Alice                (string)
  age             = 30                   (integer)
  height          = 1.68                 (float)
  count           = 42                   (integer)
  debug_flag      = 1                    (integer)

=== Variables matching 'debug_*' ===
  debug_flag      = 1                    (integer)
\end{verbatim}
\end{examplebox}

\subsection{Generador de Documentación de Procedimientos}

\begin{examplebox}[title=Generar Documentación Automáticamente]
\begin{lstlisting}[language=BCL]
PROC document_procedures DO
  SET procs [INFO PROCS]

  PUTS "==================================="
  PUTS "  BCL Procedure Documentation"
  PUTS "==================================="
  PUTS ""

  FOREACH proc IN $procs DO
    # Skip internal procedures
    IF [STRING MATCH "_*" $proc] THEN
      CONTINUE
    END

    SET params [INFO ARGS $proc]
    SET param_count [LLENGTH $params]

    PUTS "PROCEDURE: $proc"
    PUTS "Parameters: $param_count"

    IF $param_count > 0 THEN
      SET i 1
      FOREACH param IN $params DO
        PUTS "  $i. $param"
        INCR i
      END
    END

    PUTS ""
  END
END

# Define some example procedures
PROC add WITH a b DO
  RETURN [EXPR $a + $b]
END

PROC greet WITH name @title DO
  PUTS "Hello, $name"
END

PROC _internal_helper DO
  # This won't be documented
END

# Generate documentation
document_procedures
\end{lstlisting}

\textbf{Salida:}
\begin{verbatim}
===================================
  BCL Procedure Documentation
===================================

PROCEDURE: document_procedures
Parameters: 0

PROCEDURE: add
Parameters: 2
  1. a
  2. b

PROCEDURE: greet
Parameters: 2
  1. name
  2. title
\end{verbatim}
\end{examplebox}

\section{Referencia del Comando INFO}

\begin{longtable}{lp{8cm}}
\caption{Referencia de Subcomandos INFO} \\
\toprule
\textbf{Subcomando} & \textbf{Descripción} \\
\midrule
\endfirsthead
\multicolumn{2}{c}{{\tablename\ \thetable{} -- continuación}} \\
\toprule
\textbf{Subcomando} & \textbf{Descripción} \\
\midrule
\endhead
\bottomrule
\endfoot

\texttt{EXISTS varname} & Verificar si existe variable \\
\texttt{VARS [pattern]} & Listar todas las variables (o que coincidan con patrón) \\
\texttt{GLOBALS [pattern]} & Listar variables globales \\
\texttt{LOCALS [pattern]} & Listar variables locales \\
\texttt{PROCS [pattern]} & Listar todos los procedimientos \\
\texttt{COMMANDS [pattern]} & Listar todos los comandos BCL \\
\texttt{ARGS procname} & Obtener parámetros del procedimiento \\
\texttt{BODY procname} & Obtener cuerpo del procedimiento (código) \\
\texttt{BCLVERSION} & Obtener cadena de versión de BCL \\
\end{longtable}

\begin{tipbox}
¡La introspección es poderosa para construir herramientas de desarrollo, depuradores y código auto-documentado. Úsala para hacer tus programas más inteligentes y robustos!
\end{tipbox}

\begin{warningbox}
Ten cuidado al usar \cmd{INFO BODY} con nombres de procedimiento proporcionados por el usuario, ya que expone tu código. En sistemas de producción, considera restringir el acceso a comandos de introspección.
\end{warningbox}
