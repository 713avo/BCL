================================================================================
PLAN DE IMPLEMENTACIÓN - INTÉRPRETE BCL v1.5
================================================================================
Autor: Generado por Claude Code
Fecha: Octubre 2025
Basado en las especificaciones completas de BCL v1.5 (Edición PC)
================================================================================

ÍNDICE
------
1. VISIÓN GENERAL DEL PROYECTO
2. ARQUITECTURA DEL INTÉRPRETE
3. FASES DE IMPLEMENTACIÓN
4. COMPONENTES PRINCIPALES
5. ESTRUCTURAS DE DATOS
6. IMPLEMENTACIÓN POR MÓDULOS
7. TESTING Y VALIDACIÓN
8. CRITERIOS DE ACEPTACIÓN

================================================================================
1. VISIÓN GENERAL DEL PROYECTO
================================================================================

BCL (Basic Command Language) es un lenguaje interpretado inspirado en Tcl 8.x
con sintaxis tipo BASIC. Características principales:

- Case-insensitive (todo el lenguaje)
- Todo valor es STRING (conversión dinámica)
- Bloques terminados con END
- Soporte Unicode completo
- Filosofía tipo Tcl con sintaxis más legible
- Diseñado para ser ligero y portable

Objetivo: Implementar un intérprete completo que cumpla fielmente las
especificaciones definidas en los 14 documentos de referencia.

================================================================================
2. ARQUITECTURA DEL INTÉRPRETE
================================================================================

2.1 COMPONENTES PRINCIPALES
----------------------------
┌──────────────────────────────────────────────────────────────┐
│                        REPL / Main                            │
│  (Modo interactivo + ejecución de scripts)                   │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                         PARSER                                │
│  - Tokenización                                               │
│  - Análisis sintáctico                                        │
│  - Expansión de variables ($var)                             │
│  - Evaluación de comandos [ ]                                │
│  - Manejo de comillas y escapes                              │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                     EVALUADOR PRINCIPAL                       │
│  - Dispatch de comandos                                       │
│  - Gestión de ámbitos (scopes)                               │
│  - Manejo de flujo de control                                │
│  - Gestión de errores                                         │
└──────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌──────────────┐    ┌──────────────┐      ┌──────────────┐
│  COMANDOS    │    │   CONTROL    │      │  ENTORNO     │
│  BÁSICOS     │    │   DE FLUJO   │      │  RUNTIME     │
│              │    │              │      │              │
│ SET/UNSET    │    │ IF/WHILE/FOR │      │ Variables    │
│ PUTS/GETS    │    │ SWITCH/CASE  │      │ Globales     │
│ INCR/APPEND  │    │ FOREACH      │      │ Locales      │
│ EXPR         │    │ PROC/RETURN  │      │ Procs        │
│ STRING/LIST  │    │ BREAK/CONT   │      │ Handles      │
│ FILE/OPEN    │    │ EXIT         │      │ (archivos)   │
│ FORMAT/SCAN  │    │              │      │              │
│ REGEXP       │    │              │      │              │
│ INFO/CLOCK   │    │              │      │              │
└──────────────┘    └──────────────┘      └──────────────┘

2.2 FLUJO DE EJECUCIÓN
----------------------
1. Lectura de línea/script
2. Tokenización (separación por espacios, respetando comillas)
3. Expansión de variables ($var)
4. Evaluación de subcomandos [...]
5. Decodificación de secuencias de escape
6. Ejecución del comando
7. Retorno del resultado

================================================================================
3. FASES DE IMPLEMENTACIÓN
================================================================================

FASE 1: NÚCLEO BÁSICO (Prioridad Alta)
---------------------------------------
□ 1.1 Parser y Tokenizador
    - Tokenización por espacios
    - Manejo de comillas simples y dobles
    - Expansión de variables $var
    - Evaluación de subcomandos [...]
    - Comentarios (#)
    - Secuencias de escape básicas (\n, \t, etc.)
    - Soporte Unicode

□ 1.2 Entorno de Ejecución
    - Gestión de variables globales (hashtable case-insensitive)
    - Stack de ámbitos para procedimientos
    - Registro de procedimientos definidos
    - Manejo de errores y excepciones
    - Estado del intérprete

□ 1.3 Comandos Básicos de Variables
    - SET nombre [valor]
    - UNSET nombre
    - GLOBAL var1 var2 ...
    - INCR var [incremento]
    - APPEND var valor1 valor2 ...

□ 1.4 I/O Básico
    - PUTS texto
    - PUTSN texto
    - GETS (stdin)

□ 1.5 EXPR (Evaluador de Expresiones)
    - Operadores aritméticos: + - * / % ^
    - Operadores de comparación: = != < <= > >=
    - Operadores lógicos: AND OR NOT && || !
    - Operadores bitwise: & | ^ ~ << >>
    - Paréntesis para precedencia
    - Funciones matemáticas: abs, sqrt, pow, sin, cos, tan, etc.
    - Funciones de conversión: int, double
    - Funciones aleatorias: rand(), srand()
    - Manejo de enteros, flotantes, hex (0x), científica

FASE 2: CONTROL DE FLUJO (Prioridad Alta)
------------------------------------------
□ 2.1 Estructuras Condicionales
    - IF condición THEN ... [ELSEIF ...] [ELSE ...] END
    - SWITCH expr DO CASE val1 ... CASE val2 ... DEFAULT ... END
    - Condiciones directas (sin EXPR explícito cuando aplique)

□ 2.2 Bucles
    - WHILE condición DO ... END
    - FOR [SET var inicio] TO condición DO ... END
    - FOR inicio TO fin [STEP incremento] DO ... END (con $__FOR)
    - FOREACH var IN lista DO ... END
    - BREAK
    - CONTINUE

□ 2.3 Procedimientos
    - PROC nombre WITH param1 param2 @param3 DO ... END
    - RETURN [valor]
    - Gestión de ámbito local
    - Parámetros opcionales (@param)
    - Recursividad
    - Invocación por nombre (sin CALL)

FASE 3: MANIPULACIÓN DE DATOS (Prioridad Media)
------------------------------------------------
□ 3.1 Listas
    - LIST elem1 elem2 ...
    - SPLIT texto separador
    - JOIN lista separador
    - LINDEX lista índice
    - LRANGE lista inicio fin
    - LLENGTH lista
    - LAPPEND lista elementos...
    - LINSERT lista índice elementos...
    - LREPLACE lista inicio fin [nuevos...]
    - CONCAT lista1 lista2 ...
    - LSORT lista
    - LSEARCH lista valor

□ 3.2 Strings (STRING subcomando ...)
    - CAT s1 s2 ...
    - COMPARE s1 s2 [CASE NOCASE] [LENGTH n]
    - EQUAL s1 s2 [CASE NOCASE] [LENGTH n]
    - FIRST needle haystack [START i]
    - LAST needle haystack [LAST i]
    - INDEX s i
    - IS clase s [STRICT] [FAILINDEX var]
      Clases: ALNUM ALPHA ASCII BOOLEAN CONTROL DIGIT DOUBLE ENTIER
              FALSE GRAPH INTEGER LIST LOWER PRINT PUNCT SPACE TRUE
              UPPER WIDEINTEGER WORDCHAR XDIGIT
    - LENGTH s
    - MAP mapping s [CASE NOCASE]
    - MATCH pattern s [CASE NOCASE]
    - RANGE s first last
    - REPEAT s count
    - REPLACE s first last [new]
    - REVERSE s
    - TOLOWER s [first [last]]
    - TOTITLE s [first [last]]
    - TOUPPER s [first [last]]
    - TRIM s [chars]
    - TRIMLEFT s [chars]
    - TRIMRIGHT s [chars]
    - WORDSTART s charIndex
    - WORDEND s charIndex
    - BYTELENGTH s (obsoleto pero documentado)

□ 3.3 Format y Scan
    - FORMAT plantilla arg1 arg2 ...
      Especificadores: %d %f %s %x %o %c %e %g
      Modificadores: ancho, precisión, alineación (%-10s, %05d, %.2f)
    - SCAN texto plantilla var1 var2 ...
      Mismo formato que FORMAT
      Retorna número de valores leídos

FASE 4: ARCHIVOS Y SISTEMA (Prioridad Media)
---------------------------------------------
□ 4.1 Manejo de Archivos
    - OPEN ruta modo → handle
      Modos: R W A RW
    - CLOSE handle
    - READ handle [n]
    - GETS handle → línea
    - PUTS handle texto
    - PUTSN handle texto
    - TELL handle → posición
    - SEEK handle offset whence
      whence: SET CUR END
    - EOF handle → 0|1

□ 4.2 Operaciones de Archivos
    - FILE EXISTS ruta → 0|1
    - FILE SIZE ruta → bytes
    - FILE DELETE ruta
    - FILE RENAME src dst

□ 4.3 Sistema de Archivos
    - PWD → directorio actual
    - GLOB patrón [DIRECTORY dir] [TAILS] [NOCOMPLAIN] [TYPES tipo...]
      Tipos: d (dirs), f (files)

FASE 5: EXPRESIONES REGULARES (Prioridad Media)
------------------------------------------------
□ 5.1 REGEXP
    - REGEXP patrón texto [opciones]
      Opciones: NOCASE LINE LINESTOP LINEANCHOR EXPANDED ALL
                INDICES START n
                MATCH var SUBMATCHES v1 v2 ...
    - Motor de regex compatible Tcl ARE

□ 5.2 REGSUB
    - REGSUB patrón texto reemplazo [opciones]
      Opciones: NOCASE LINE LINESTOP LINEANCHOR EXPANDED ALL
                START n COUNT var
    - Backreferences: \\0 \\1..\\9 o &

FASE 6: INTROSPECCIÓN Y SISTEMA (Prioridad Media)
--------------------------------------------------
□ 6.1 INFO
    - INFO EXISTS varname → 0|1
    - INFO ARGS procname → lista parámetros
    - INFO COMMANDS [pat] → lista comandos
    - INFO GLOBALS [pat] → lista variables globales
    - INFO LOCALS [pat] → lista variables locales
    - INFO PROCS [pat] → lista procedimientos
    - INFO VARS [pat] → lista variables visibles
    - INFO BCLVERSION → versión

□ 6.2 CLOCK (Manejo de Tiempo)
    - CLOCK SECONDS → segundos epoch
    - CLOCK MILLISECONDS → milisegundos epoch
    - CLOCK MICROSECONDS → microsegundos epoch (opcional)
    - CLOCK FORMAT tiempo [FORMAT fmt] [TIMEZONE tz] [LOCALE loc] [GMT]
      Especificadores: %Y %m %d %H %M %S %a %A %b %B %z %Z %j %w %U %W %s %%
    - CLOCK SCAN texto [FORMAT fmt] [TIMEZONE tz] [LOCALE loc] [BASE t0] [GMT]
    - CLOCK ADD tiempo cantidad unidad [cantidad unidad ...] [TIMEZONE tz] [GMT]
      Unidades: years months weeks days hours minutes seconds
      Reglas DST y fin de mes según Tcl

FASE 7: COMANDOS DE SISTEMA (Prioridad Baja)
---------------------------------------------
□ 7.1 Integración con Sistema
    - EVAL código
    - SOURCE ruta
    - AFTER milisegundos (equivalente a SLEEP)
    - EXEC comando [args...] (solo PC, captura stdout)
    - ENV nombre
    - ARGV → lista argumentos
    - EXIT [código]

FASE 8: MODO INTERACTIVO Y UTILIDADES (Prioridad Baja)
-------------------------------------------------------
□ 8.1 REPL (Read-Eval-Print Loop)
    - Prompt "BCL> "
    - Continuación de líneas
    - Historia de comandos (readline si disponible)
    - Manejo de Ctrl+C
    - Manejo de Ctrl+D (salida)

□ 8.2 Utilidades de Desarrollo
    - Mensajes de error descriptivos
    - Stack traces en errores
    - Modo debug (opcional)
    - Profiling (opcional)

================================================================================
4. COMPONENTES PRINCIPALES - DETALLE
================================================================================

4.1 TOKENIZADOR
---------------
Responsabilidades:
- Dividir entrada en tokens respetando:
  * Espacios como separadores
  * Comillas " " y ' ' para agrupar
  * Escapes con \
  * Secuencias Unicode \uXXXX
- Identificar comentarios (#)
- Preservar estructura para expansión posterior

Entrada: String de código BCL
Salida: Lista de tokens

4.2 PARSER
----------
Responsabilidades:
- Reconocer comandos y argumentos
- Expandir variables ($var)
- Evaluar subcomandos [...]
- Decodificar escapes
- Construir AST (opcional) o ejecutar directamente

Entrada: Lista de tokens
Salida: Comandos ejecutables

4.3 EVALUADOR DE EXPRESIONES (EXPR)
------------------------------------
Responsabilidades:
- Parsear expresiones aritméticas/lógicas
- Evaluar con precedencia correcta
- Soportar funciones matemáticas
- Conversión automática string↔número

Técnica recomendada:
- Shunting Yard + evaluación RPN, o
- Recursive Descent Parser, o
- Parser Combinators

4.4 ENTORNO DE RUNTIME
----------------------
Estructuras:
- Variables globales: HashMap<String, String> (case-insensitive)
- Stack de scopes: Vec<HashMap<String, String>>
- Tabla de procedimientos: HashMap<String, ProcDef>
- Handles de archivos: HashMap<String, FileHandle>
- Estado del intérprete

4.5 GESTIÓN DE ÁMBITOS
----------------------
- Ámbito global: siempre presente
- Ámbitos locales: uno por cada llamada a PROC
- GLOBAL: marca variables para búsqueda en ámbito global

Búsqueda de variable:
1. Buscar en ámbito local actual (si existe)
2. Buscar en globales marcadas con GLOBAL
3. Si no está, error

4.6 MOTOR DE REGEXP
-------------------
Opciones:
- Usar librería existente compatible Tcl ARE (ej: regex crate en Rust)
- Implementar subconjunto básico (más trabajo)

Recomendación: Usar librería externa madura

================================================================================
5. ESTRUCTURAS DE DATOS PRINCIPALES
================================================================================

5.1 CÓDIGO RUST (EJEMPLO CONCEPTUAL)
-------------------------------------

```rust
// Entorno de ejecución
struct Interpreter {
    global_vars: HashMap<String, String>,     // case-insensitive
    scopes: Vec<Scope>,                       // stack de ámbitos locales
    procedures: HashMap<String, Procedure>,   // case-insensitive
    file_handles: HashMap<String, FileHandle>,
    break_flag: bool,
    continue_flag: bool,
    return_value: Option<String>,
}

// Ámbito local
struct Scope {
    vars: HashMap<String, String>,            // variables locales
    globals: HashSet<String>,                 // variables marcadas GLOBAL
}

// Definición de procedimiento
struct Procedure {
    name: String,
    params: Vec<Parameter>,
    body: Vec<String>,                        // líneas del cuerpo
}

struct Parameter {
    name: String,
    optional: bool,                           // true si es @param
}

// Token
enum Token {
    Word(String),
    Variable(String),                         // $var
    SubCommand(Vec<Token>),                   // [...]
    QuotedString(String),
}

// Handle de archivo
struct FileHandle {
    file: File,
    mode: FileMode,
}

enum FileMode {
    Read,
    Write,
    Append,
    ReadWrite,
}
```

5.2 TIPOS DE DATOS
------------------
En BCL todo es String, pero internamente podemos optimizar:
- Mantener strings como UTF-8
- Conversión lazy a número solo cuando EXPR lo requiera
- Cache de conversiones (opcional)

5.3 CASE-INSENSITIVE
--------------------
Implementación:
- Todas las claves de hashmaps en lowercase
- Normalizar nombres de comandos, variables, procedimientos al buscar
- Preservar case original en valores

================================================================================
6. IMPLEMENTACIÓN POR MÓDULOS
================================================================================

6.1 MÓDULO: tokenizer.rs
-------------------------
Funciones:
- tokenize(input: &str) → Vec<Token>
- handle_escapes(s: &str) → String
- is_comment(line: &str) → bool

6.2 MÓDULO: parser.rs
---------------------
Funciones:
- parse_command(tokens: &[Token]) → Command
- expand_variables(token: &Token, env: &Interpreter) → String
- eval_subcommand(tokens: &[Token], env: &mut Interpreter) → String

6.3 MÓDULO: expr.rs
-------------------
Funciones:
- eval_expr(expr: &str, env: &Interpreter) → Result<String, Error>
- parse_expression(expr: &str) → AST
- apply_operators(ast: &AST) → Value

Funciones matemáticas:
- math_sin, math_cos, math_tan, math_asin, math_acos, math_atan
- math_sqrt, math_pow, math_exp, math_ln, math_log
- math_abs, math_int, math_double
- math_ceil, math_floor, math_round
- math_hypo, math_rand, math_srand

6.4 MÓDULO: commands/
----------------------
Submodulos:
- variables.rs: SET, UNSET, GLOBAL, INCR, APPEND
- io.rs: PUTS, PUTSN, GETS
- lists.rs: LIST, SPLIT, JOIN, LINDEX, LRANGE, etc.
- strings.rs: STRING (todos los subcomandos)
- files.rs: OPEN, CLOSE, READ, GETS (file), PUTS (file), FILE, PWD, GLOB
- format.rs: FORMAT, SCAN
- regexp.rs: REGEXP, REGSUB
- info.rs: INFO (todos los subcomandos)
- clock.rs: CLOCK (todos los subcomandos)
- system.rs: EVAL, SOURCE, AFTER, EXEC, ENV, ARGV, EXIT

6.5 MÓDULO: control_flow.rs
---------------------------
Funciones:
- cmd_if, cmd_elseif, cmd_else, cmd_end (gestión de bloques)
- cmd_switch, cmd_case, cmd_default
- cmd_while
- cmd_for (ambos modos)
- cmd_foreach
- cmd_break, cmd_continue
- cmd_proc, cmd_return

6.6 MÓDULO: interpreter.rs
--------------------------
Estructura principal Interpreter
Funciones:
- new() → Interpreter
- eval(&mut self, code: &str) → Result<String, Error>
- dispatch_command(&mut self, cmd: &Command) → Result<String, Error>
- call_procedure(&mut self, name: &str, args: &[String]) → Result<String, Error>
- push_scope, pop_scope
- get_var, set_var, unset_var

6.7 MÓDULO: repl.rs
-------------------
Funciones:
- run_repl(interp: &mut Interpreter)
- read_line() → String
- handle_multiline() → String

6.8 MÓDULO: main.rs
-------------------
Punto de entrada:
- Parsear argumentos (script o REPL)
- Inicializar intérprete
- Ejecutar script o entrar en REPL
- Capturar errores y mostrar mensajes

================================================================================
7. TESTING Y VALIDACIÓN
================================================================================

7.1 TESTS UNITARIOS
-------------------
Por cada módulo:
- Tokenizador: casos con comillas, escapes, variables, subcomandos
- Parser: expansión de variables, evaluación de subcomandos
- EXPR: operadores, precedencia, funciones matemáticas
- Comandos: cada comando con casos normales y edge cases

7.2 TESTS DE INTEGRACIÓN
-------------------------
Scripts BCL completos que prueben:
- Variables y ámbitos
- Control de flujo (IF, WHILE, FOR, SWITCH)
- Procedimientos y recursividad
- Listas y strings
- Archivos
- Expresiones regulares
- INFO y CLOCK

7.3 TESTS DE CONFORMIDAD
-------------------------
Basados en las especificaciones:
- Cada ejemplo de los manuales debe ejecutarse correctamente
- Comparar salidas con comportamiento esperado
- Verificar mensajes de error

7.4 SUITE DE TESTS
------------------
Crear carpeta tests/ con:
- test_variables.bcl
- test_control.bcl
- test_procedures.bcl
- test_lists.bcl
- test_strings.bcl
- test_files.bcl
- test_regexp.bcl
- test_expr.bcl
- test_clock.bcl
- test_info.bcl
- test_integration.bcl

Ejecutor de tests:
- Script que ejecuta cada .bcl y verifica salida esperada

================================================================================
8. CRITERIOS DE ACEPTACIÓN
================================================================================

8.1 FUNCIONALIDAD
-----------------
□ Todos los comandos documentados funcionan según especificación
□ Case-insensitive en comandos, variables, procedimientos
□ Expansión de variables $var correcta
□ Evaluación de subcomandos [...] correcta
□ Secuencias de escape y Unicode funcionan
□ Comentarios # se ignoran correctamente

8.2 CONTROL DE FLUJO
---------------------
□ IF/ELSEIF/ELSE/END funciona con todas las condiciones
□ SWITCH/CASE/DEFAULT funciona correctamente
□ WHILE ejecuta correctamente con BREAK/CONTINUE
□ FOR (ambos modos) funciona según especificación
□ FOREACH itera listas correctamente
□ PROC define y ejecuta procedimientos
□ Parámetros opcionales (@param) funcionan con INFO EXISTS
□ Recursividad funciona sin límites artificiales bajos
□ RETURN sale de procedimientos correctamente

8.3 EXPRESIONES
---------------
□ EXPR evalúa aritmética con precedencia correcta
□ Operadores lógicos y comparación funcionan
□ Funciones matemáticas devuelven valores correctos
□ Conversión automática string↔número funciona
□ Notación hexadecimal y científica se parsea correctamente

8.4 DATOS
---------
□ Listas (LIST, LINDEX, LAPPEND, etc.) funcionan
□ STRING (todos los 20+ subcomandos) funcionan según Tcl 8.6
□ FORMAT y SCAN con especificadores %d %f %s etc. funcionan
□ Conversiones de formato correctas

8.5 ARCHIVOS
------------
□ OPEN/CLOSE/READ/GETS/PUTS funcionan con archivos
□ TELL/SEEK/EOF funcionan correctamente
□ FILE EXISTS/SIZE/DELETE/RENAME funcionan
□ PWD devuelve directorio actual
□ GLOB expande patrones correctamente con opciones

8.6 REGEXP
----------
□ REGEXP busca y captura subgrupos
□ REGSUB sustituye con backreferences
□ Opciones NOCASE, ALL, INDICES, etc. funcionan

8.7 INTROSPECCIÓN
-----------------
□ INFO EXISTS detecta variables
□ INFO ARGS lista parámetros de procedimientos
□ INFO COMMANDS/PROCS/GLOBALS/LOCALS/VARS funcionan
□ INFO BCLVERSION devuelve versión correcta

8.8 TIEMPO
----------
□ CLOCK SECONDS/MILLISECONDS devuelven época Unix
□ CLOCK FORMAT formatea fechas según especificadores
□ CLOCK SCAN parsea fechas
□ CLOCK ADD suma intervalos con reglas DST y fin de mes

8.9 SISTEMA
-----------
□ EVAL ejecuta código dinámicamente
□ SOURCE carga y ejecuta archivos externos
□ AFTER pausa la ejecución
□ EXEC (PC) ejecuta comandos del sistema y captura salida
□ ENV lee variables de entorno
□ ARGV devuelve argumentos del script
□ EXIT termina con código de salida

8.10 REPL
---------
□ Prompt "BCL> " funciona
□ Líneas múltiples se manejan correctamente
□ Errores se muestran sin crashear el REPL
□ Ctrl+D sale del REPL

8.11 RENDIMIENTO
----------------
□ Intérprete arranca en < 100ms
□ Ejecución de scripts simples es fluida
□ No hay memory leaks
□ Recursividad profunda no causa stack overflow inmediato

8.12 CALIDAD DE CÓDIGO
----------------------
□ Código documentado con comentarios
□ Estructura modular clara
□ Manejo de errores consistente
□ Tests cubren > 80% del código
□ Sin warnings del compilador

================================================================================
9. CRONOGRAMA ESTIMADO
================================================================================

Asumiendo dedicación completa:

SEMANA 1-2: Fase 1 (Núcleo básico)
  - Parser, tokenizador, entorno
  - SET, UNSET, GLOBAL, INCR, APPEND
  - PUTS, PUTSN, GETS
  - EXPR (completo con funciones matemáticas)

SEMANA 3: Fase 2 (Control de flujo)
  - IF/ELSEIF/ELSE/END
  - SWITCH/CASE/DEFAULT/END
  - WHILE, FOR (ambos modos), FOREACH
  - BREAK, CONTINUE
  - PROC, RETURN

SEMANA 4: Fase 3 (Datos)
  - Comandos de listas (LIST, LINDEX, etc.)
  - STRING (todos los subcomandos)
  - FORMAT, SCAN

SEMANA 5: Fase 4 (Archivos)
  - OPEN, CLOSE, READ, GETS, PUTS (handle)
  - TELL, SEEK, EOF
  - FILE (EXISTS, SIZE, DELETE, RENAME)
  - PWD, GLOB

SEMANA 6: Fase 5 (Regexp)
  - REGEXP con capturas
  - REGSUB con backreferences
  - Integración con librería regex

SEMANA 7: Fase 6 (Introspección)
  - INFO (todos los subcomandos)
  - CLOCK (todos los subcomandos)

SEMANA 8: Fase 7 y 8 (Sistema y REPL)
  - EVAL, SOURCE, AFTER, EXEC, ENV, ARGV, EXIT
  - REPL con readline
  - Pulido y debugging

SEMANA 9-10: Testing y Validación
  - Suite completa de tests
  - Debugging
  - Optimizaciones
  - Documentación

Total estimado: 10 semanas (2.5 meses) a tiempo completo

================================================================================
10. TECNOLOGÍAS RECOMENDADAS
================================================================================

10.1 LENGUAJE DE IMPLEMENTACIÓN
--------------------------------
Opciones:
1. Rust (recomendado)
   + Rendimiento excelente
   + Seguridad de memoria
   + Ecosistema maduro
   + Pattern matching ideal para parsers
   - Curva de aprendizaje

2. C
   + Máximo rendimiento
   + Portable
   - Gestión manual de memoria
   - Más propenso a bugs

3. Go
   + Simplicidad
   + Buenos strings/Unicode
   + GC automático
   ~ Rendimiento ligeramente menor que Rust/C

4. Python (prototipado rápido)
   + Desarrollo muy rápido
   + Buenas librerías
   - Rendimiento menor
   - No ideal para embebidos

Recomendación: Rust para producción, Python para prototipo inicial

10.2 LIBRERÍAS CLAVE (RUST)
---------------------------
- regex: Expresiones regulares
- chrono: Manejo de fechas/tiempo para CLOCK
- rustyline: Readline para REPL
- lazy_static: Variables globales estáticas
- unicode-segmentation: Segmentación Unicode
- glob: Expansión de patrones de archivos

10.3 HERRAMIENTAS
-----------------
- Git: Control de versiones
- Cargo: Build system (Rust)
- Clippy: Linter (Rust)
- Valgrind/Miri: Detección de memory leaks
- GDB/LLDB: Debugging

================================================================================
11. RIESGOS Y MITIGACIONES
================================================================================

RIESGO 1: Complejidad del parser
Mitigación: Usar parser combinators (nom en Rust) o generador (pest)

RIESGO 2: Compatibilidad Unicode
Mitigación: Usar librerías maduras, testing exhaustivo con caracteres no-ASCII

RIESGO 3: Regexp compatible con Tcl
Mitigación: Usar librería que soporte flavor ARE o PCRE similar

RIESGO 4: CLOCK con zonas horarias
Mitigación: Usar librería chrono-tz que soporta base IANA

RIESGO 5: Performance en recursividad profunda
Mitigación: Optimización de tail calls o límite configurable

RIESGO 6: Bugs en casos edge de STRING
Mitigación: Tests exhaustivos basados en tests de Tcl

================================================================================
12. EXTENSIBILIDAD FUTURA
================================================================================

Diseñar para permitir:
- Añadir comandos personalizados (plugins)
- FFI para llamar código C/nativo
- Embedar en aplicaciones C/C++
- Compilación a bytecode (optimización futura)
- JIT (muy avanzado, opcional)

================================================================================
13. DOCUMENTACIÓN A GENERAR
================================================================================

□ README.md: Introducción, instalación, uso básico
□ INSTALL.md: Instrucciones de compilación
□ CONTRIBUTING.md: Guía para contribuidores
□ API.md: API interna para extensiones
□ EXAMPLES/: Carpeta con scripts de ejemplo
□ REFERENCE.md: Referencia rápida de comandos
□ CHANGELOG.md: Historial de versiones

================================================================================
14. ENTREGABLES
================================================================================

□ Código fuente del intérprete
□ Suite de tests completa
□ Documentación de usuario
□ Documentación de desarrollador
□ Scripts de ejemplo
□ Binario compilado para al menos Linux x64
□ Opcional: Binarios para Windows, macOS, ARM

================================================================================
15. NOTAS FINALES
================================================================================

PRINCIPIOS DE DISEÑO:
1. Fidelidad a las especificaciones Tcl/BCL
2. Claridad sobre complejidad
3. Correctitud sobre velocidad (en primera iteración)
4. Testing exhaustivo
5. Código mantenible

ORDEN DE PRIORIDADES:
1. Funcionalidad correcta
2. Tests que pasen
3. Código limpio
4. Optimización

HITOS CRÍTICOS:
- Parser funcionando con expansión de variables
- EXPR evaluando correctamente
- Control de flujo (IF, WHILE, PROC)
- Listas y strings básicos
- Archivos I/O
- REPL funcional

Una vez logrados estos hitos, el resto es implementación de comandos
siguiendo los patrones establecidos.

================================================================================
FIN DEL PLAN DE IMPLEMENTACIÓN
================================================================================

Este plan detalla paso a paso la implementación de un intérprete BCL v1.5
completo siguiendo fielmente las especificaciones proporcionadas.

Última actualización: Octubre 2025
